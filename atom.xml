<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伏窗尾的猫</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-20T03:14:57.368Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>喵呜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习之路 —— 进程与线程　　（一）</title>
    <link href="http://yoursite.com/2018/09/20/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%20%E2%80%94%E2%80%94%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/09/20/学习之路 —— 进程与线程/</id>
    <published>2018-09-20T05:58:20.000Z</published>
    <updated>2018-09-20T03:14:57.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习之路-——-进程与线程"><a href="#学习之路-——-进程与线程" class="headerlink" title="学习之路 —— 进程与线程"></a>学习之路 —— 进程与线程</h1><h2 id="一、进程和线程关系及区别"><a href="#一、进程和线程关系及区别" class="headerlink" title="一、进程和线程关系及区别"></a>一、进程和线程关系及区别</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>　　进程是<strong>独立功能</strong>的程序关于某个<strong>数据集合</strong>上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。<br>　　线程是进程中的一个实体，是cpu调度和分配的基本单位，但线程基本不拥有系统资源。</p><h3 id="2、关系"><a href="#2、关系" class="headerlink" title="2、关系"></a>2、关系</h3><p>　　<br>　　进程是一个动态的概念，线程是进程中的一部分，<strong>一个程序至少有一个进程，一个进程至少有一个线程</strong>。两者均能实现并发。　　</p><p>###3、分别</p><p>　　1）地址空间：线程间共享同一进程的地址空间，进程有自己独立的地址空间。<br>　　2）资源拥有：进程是资源分配和拥有的单位，同进程的线程共享进程资源。　　　　</p><h3 id="4、优劣"><a href="#4、优劣" class="headerlink" title="4、优劣"></a>4、优劣</h3><p>　　1）线程是处理器调度的基本单位，其划分的尺度小于进程，使得多线程程序的并发性高。</p><p>　　2）进程在执行过程中拥有独立的内存单元，而多个线程之间共享内存，运行效率高，但由于共享内存，导致线程与线程间互有影响，其中一个线程死亡会导致整个进程死掉，所以多进程程序比多线程程序健壮，但进程切换耗费资源大，效益低。</p><p>　　3）线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>　　4）从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><p>　　5）线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习之路-——-进程与线程&quot;&gt;&lt;a href=&quot;#学习之路-——-进程与线程&quot; class=&quot;headerlink&quot; title=&quot;学习之路 —— 进程与线程&quot;&gt;&lt;/a&gt;学习之路 —— 进程与线程&lt;/h1&gt;&lt;h2 id=&quot;一、进程和线程关系及区别&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="学习之路" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="进程与线程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>学习之路 —— 进程与线程　　（二）</title>
    <link href="http://yoursite.com/2018/09/20/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/09/20/学习之路——进程/</id>
    <published>2018-09-20T05:58:20.000Z</published>
    <updated>2018-09-28T12:17:59.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h1><p></p><p style="background-color:rgb(125,255,0)">　　进程——进程是独立功能的程序关于某个数据集合上的一次运行活动！</p><h2 id="1-1-创建进程函数"><a href="#1-1-创建进程函数" class="headerlink" title="1.1 创建进程函数"></a>1.1 创建进程函数</h2><pre><code>头文件： #include &lt;unistd.h&gt;原型： pid_t fork(void);功能：创建一个进程 返回值：子进程 返回0 父进程 返回子进程的ID </code></pre><p>fork简介：fork函数创建了一个新的进程，新的进程即子进程将复制父进程所有的数据与指令，子进程拥有独立的内存空间以及系统资源。</p><p>问题一：fork 成功后子进程从哪里开始执行？</p><p>　　从调用完fork后面的语句处开始执行！</p><p>问题二：父子进程的执行顺序是怎样的？</p><p>　　由时间片轮转调度决定，没有固定的执行顺序。</p><p>问题三：什么是时间片？</p><p>　　时间片：为实现并发，每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。若时间片结束进程还在运行，则cpu将被剥夺并分配给另一个进程，若进程在时间片结束前阻塞或结束，则cpu当即切换。系统内进程按时间顺序排成一个队列，每次调度，系统都将cpu分配给队内首进程，此进程用完它的时间片后被移动到队列的末尾，接着下一个执行。<br>　　时间片过短：导致过多的进程切换，降低效率。<br>　　时间片过长：引起对短的交互请求响应变差。</p><h2 id="1-2-获取标识码函数"><a href="#1-2-获取标识码函数" class="headerlink" title="1.2 获取标识码函数"></a>1.2 获取标识码函数</h2><pre><code>头文件： #include &lt;unistd.h&gt;        #include &lt;sys/types.h&gt;原型： pid_t getpid(void); //获取本身ID       pid_t getppid(void);//获取父进程ID 功能：获取进程号 返回值：返回所获取的PID</code></pre><h2 id="1-3-进程退出函数"><a href="#1-3-进程退出函数" class="headerlink" title="1.3 进程退出函数"></a>1.3 进程退出函数</h2><p>exit:</p><pre><code>头文件：#include&lt;stdlib.h&gt;原型：void exit(int status)；功能：用来退出进程，进行清除操作参数： 退出码，stasus用来存返回值。</code></pre><p>_exit:</p><pre><code>头文件：#include&lt;unistd.h&gt;原型：void _exit(int status);功能：用来退出进程，立即退出参数： 退出码，stasus用来存返回值。</code></pre><p>_Exit:</p><pre><code>头文件：#include&lt;stdlib.h&gt;原型：void _Exit(int status);功能：用来退出进程，立即退出参数： 退出码，stasus用来存返回值。</code></pre><p>进程死亡：自杀与被杀。自杀：自然死亡与调用退出函数。<br>思考：<br>问题一：return和exit有什么区别？</p><p>a.exit是一个函数，有参数。exit执行完后把控制权交给系统。 </p><p>b.return是函数执行完后的返回。renturn执行完后把控制权交给调用函数。</p><p>问题二：exit与_exit有什么异同？</p><p>相同点：都是用来终止进程的，执行这两个函数时，系统无条件终止所有操作，清除数据，终止进程运行。<br>不同点：_exit执行后立即返回给内核，exit先执行一些清除操作再将控制权交给内核。<br>清除操作：刷新流（stdin，stdout …）,将缓冲区的数据处理完成。</p><p>c.通过实例来区别<br>实例1：exit.c</p><blockquote><p>1 #include “stdio.h”<br>2 #include “stdlib.h”<br>3<br>4 int main()<br>5 {<br>6 printf(“using exit—-\n”);<br>7 printf(“This is the content in buffer”);<br>8 exit(0);<br>9 } </p></blockquote><p>执行结果：</p><blockquote><p>using exit—-<br>This is the content in buffer</p></blockquote><p>实例2：_exit.c</p><blockquote><p>1 #include”stdio.h”<br>2 #include”unistd.h”<br>3<br>4 int main(void)<br>5 {<br>6 printf(“using _exit–\n”);<br>7 printf(“This is the content in buffer”);<br>8 _exit(0);<br>9 }</p></blockquote><p>执行结果：</p><blockquote><p>using exit—-</p></blockquote><p>printf函数就是使用缓冲I/O的方式，该函数在遇到“\n”换行符时自动的从缓冲区中将记录读出。所以exit()将缓冲区的数据写完后才退出，而_exit()函数直接退出。 </p><h2 id="1-4等待子进程结束函数"><a href="#1-4等待子进程结束函数" class="headerlink" title="1.4等待子进程结束函数"></a>1.4等待子进程结束函数</h2><p>wait:</p><pre><code>头文件：#include &lt;sys/types.h&gt;       #include &lt;sys/wait.h&gt;原型：pid_t wait(int *status);功能：等待任意一个子进程状态改变参数： 退出码，stasus用来存子进程返回值。返回值：成功返回 等待到的子进程进程号    失败返回-1 同时errno被设置</code></pre><p>waitpid    :</p><pre><code>头文件：#include &lt;sys/types.h&gt;       #include &lt;sys/wait.h&gt;原型：pid_t waitpid(pid_t pid, int *status, int options);功能：等待任意一个子进程状态改变参数： pid :指定要等待的进程号     stasus :用来存子进程返回值。    options :等待模式：0 表示默认选项 阻塞等待                WNOHANG 非阻塞等待 假设此时没有子进程退出就立刻返回 不用等待！返回值：成功返回 等待到的子进程进程号       失败返回-1 同时errno被设置</code></pre><p>退出码解析：status用来保存子进程的退出状态的信息，用以下宏来解析。</p><p>WIFEXITED（status） ：如果为真，子进程正常退出。</p><p>WEXITSTATUS (status) ：返回子进程的退出码<br>正常退出 main函数的返回值或者exit _Exit _exit 的参数<br>WIFSIGNALED （status） ：如果为真则表示这个子进程是被一个信号干掉的！<br>WCONTINUED （status）  ：如果为真表示 这个子进程是被信号唤醒的！</p><h1 id="二、exec函数族"><a href="#二、exec函数族" class="headerlink" title="二、exec函数族"></a>二、exec函数族</h1><p></p><p style="background-color:rgb(125,255,0)">　　让另外一个程序文件的数据和指令集合 替换 之前拷贝的数据指令！注意这里的替换只能替换 用户数据和指令 系统数据无法替换！</p><p>如图所示：<img src="/2018/09/20/学习之路——进程/exec函数族.png" alt="进程状态"></p><h2 id="1-1综述exec函数族"><a href="#1-1综述exec函数族" class="headerlink" title="1.1综述exec函数族"></a>1.1综述exec函数族</h2><pre><code>&gt;头文件：#include &lt;unistd.h&gt;原型：#include &lt;unistd.h&gt;extern char **environ;int execl(const char *path,const char *arg, ...);int execlp(const char *file, const char *arg, ...);int execle(const char *path,const char *arg,..., char * const envp[]);int execv(const char *path,char *const argv[]);int execvp(const char *file, char *const argv[]);int execve(const char *file,char *const argv[],char *const envp[]);功能： exec函数族装入并运行程序path/file，并将参数arg0(arg1, arg2, argv[], envp[])传递给子程序参数： path :要运行的程序       arg  :存放参数。返回值：出错返回-1，</code></pre><p>l：list：希望接收到以逗号分隔的参数列表，列表以NULL指针作为结束标志。<br>　　　　　把要执行的那个程序文件的参数，以list的形式输出。<br>v：vector：希望接收到一个以NULL结尾的字符串数组的指针（char* argv[]）<br>　　    　　　把要执行的程序文件的参数 以向量即数组的方式出现<br>p:path：环境变量：整个系统中任何一个进程都可以访问的变量。<br>　　　　　一个以NULL结尾的字符串数组指针，函数可以DOS的PATH变量查找子程序文件<br>e:envp：函数传递指定参数envp，允许改变子进程的环境，无后缀e时，子进程使用当前程序的环境。<br>是不是看的头皮发麻？实践出真知。实例如下：</p><h2 id="2-1-头文件及字符串数组指针的声明"><a href="#2-1-头文件及字符串数组指针的声明" class="headerlink" title="2.1 头文件及字符串数组指针的声明"></a>2.1 头文件及字符串数组指针的声明</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;int main(int argc, char *argv[]){  //以NULL结尾的字符串数组的指针，适合包含v的exec函数参数  char *arg[] = {&quot;ls&quot;, &quot;-a&quot;, NULL};｝</code></pre><h2 id="2-2-创建子进程并调用函数execl"><a href="#2-2-创建子进程并调用函数execl" class="headerlink" title="2.2 创建子进程并调用函数execl"></a>2.2 创建子进程并调用函数execl</h2><ul><li><p>execl 中希望接收以逗号分隔的参数列    表，并以NULL指针为结束标志</p><p>  if( fork() == 0 )<br>  {</p><pre><code>// in clild printf( &quot;1------------execl------------\n&quot; );if( execl( &quot;/bin/ls&quot;, &quot;ls&quot;,&quot;-a&quot;, NULL ) == -1 ){  perror( &quot;execl error &quot; );  exit(1);}</code></pre><p>  }</p></li></ul><h2 id="2-3-创建子进程并调用函数execv"><a href="#2-3-创建子进程并调用函数execv" class="headerlink" title="2.3 创建子进程并调用函数execv"></a>2.3 创建子进程并调用函数execv</h2><ul><li>execv中希望接收一个以NULL结尾的字符串数组的指针<pre><code>if( fork() == 0 ){  printf(&quot;2------------execv------------\n&quot;);  if( execv( &quot;/bin/ls&quot;,arg) &lt; 0)  {    perror(&quot;execv error &quot;);    exit(1);  }}</code></pre></li></ul><h2 id="2-4-创建子进程并调用-execlp"><a href="#2-4-创建子进程并调用-execlp" class="headerlink" title="2.4 创建子进程并调用 execlp"></a>2.4 创建子进程并调用 execlp</h2><ul><li>l 　希望接收以逗号分隔的参数列表，列表以NULL指针作为结束标志</li><li><p>p　是一个以NULL结尾的字符串数组指针，函数可以DOS的PATH变量查找子程序文件</p><pre><code>if( fork() == 0 ){  printf(&quot;3------------execlp------------\n&quot;);  if( execlp( &quot;ls&quot;, &quot;ls&quot;, &quot;-a&quot;, NULL ) &lt; 0 )  {    perror( &quot;execlp error &quot; );    exit(1);  }}</code></pre></li></ul><h2 id="2-５-创建子里程并调用execvp"><a href="#2-５-创建子里程并调用execvp" class="headerlink" title="2.５ 创建子里程并调用execvp"></a>2.５ 创建子里程并调用execvp</h2><ul><li>v 　望接收到一个以NULL结尾的字符串数    组的指针</li><li><p>p　 是一个以NULL结尾的字符串数组指针，函数可以DOS的PATH变量查找子程序文件</p><pre><code> if( fork() == 0 ){   printf(&quot;4------------execvp------------\n&quot;);   if( execvp( &quot;ls&quot;, arg ) &lt; 0 )   {     perror( &quot;execvp error &quot; );     exit( 1 );   }</code></pre><p>   }</p></li></ul><h2 id="2-6-创建子进程并调用execle"><a href="#2-6-创建子进程并调用execle" class="headerlink" title="2.6 创建子进程并调用execle"></a>2.6 创建子进程并调用execle</h2><ul><li>l 　希望接收以逗号分隔的参数列表，列表以NULL指针作为结束标志</li><li><p>e　函数传递指定参数envp，允许改变子进程的环境，无后缀e时，子进程使用当前程序的环境</p><p>  if( fork() == 0 )<br>  {</p><pre><code>printf(&quot;5------------execle------------\n&quot;);if( execle(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-a&quot;, NULL, NULL) == -1 ){  perror(&quot;execle error &quot;);  exit(1);}</code></pre><p>  }</p></li></ul><h2 id="2-7-创建子进程并调用execve"><a href="#2-7-创建子进程并调用execve" class="headerlink" title="2.7 创建子进程并调用execve"></a>2.7 创建子进程并调用execve</h2><ul><li>v 　希望接收到一个以NULL结尾的字符串数组的指针</li><li><p>e 　函数传递指定参数envp，允许改变子进程的环境，无后缀e时，子进程使用当前程序的环境</p><pre><code>if( fork() == 0 ){  printf(&quot;6------------execve-----------\n&quot;);  if( execve( &quot;/bin/ls&quot;, arg, NULL ) == 0)  {   perror(&quot;execve error &quot;);    exit(1);  }}</code></pre></li></ul><h2 id="2-8-类exec函数"><a href="#2-8-类exec函数" class="headerlink" title="2.8 类exec函数"></a>2.8 类exec函数</h2><p>system：用来执行指定的命令或程序<br>    &gt;头文件:#include &lt;stdlib.h&gt;<br>     原型：int system(const char *command);<br>    参数： command 要执行的指令 或者程序<br>    返回值  失败  返回 -1<br>           成功  除此以外进程的 退出码！</p><p>实例：<br>    &gt;cmd[256];<br>    sprintf(cmd,”%s %s %s”,”./hello”,”1”,”2”)<br>    system(cmd);</p><p>文终。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、进程&quot;&gt;&lt;a href=&quot;#一、进程&quot; class=&quot;headerlink&quot; title=&quot;一、进程&quot;&gt;&lt;/a&gt;一、进程&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;background-color:rgb(125,255,0)&quot;&gt;　　进程——进程是独立功能的程
      
    
    </summary>
    
      <category term="学习之路" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="进程与线程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>简易hexo的搭建　　（一）</title>
    <link href="http://yoursite.com/2018/09/08/GCC%E4%B8%8B%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%83%B0%E6%80%A7%E8%BF%90%E7%AE%97%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/09/08/GCC下逻辑运算符的惰性运算与优先级的思考/</id>
    <published>2018-09-08T05:58:20.000Z</published>
    <updated>2018-09-08T09:06:32.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建须知"><a href="#搭建须知" class="headerlink" title="搭建须知"></a>搭建须知</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始前，你必须已经：</p><pre><code>1.有一个github账号2.安装好git for windows3.安装有node.js、npm，并有一定的了解</code></pre><h1 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>　　新建一个名为 (用户名.github.io)的仓库，例如你的用户名为test<br>则创建一个名为test.github.io的仓库，将来你的网站访问地址为</p><pre><code>http：//用户名.github.io</code></pre><p>　　是不是很方便，但每个github账户只能有一个这样可以直接访问域名的仓库。创建成功后，以后你网站的所有代码都放在这个仓库啦。</p><h2 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h2><p>　　为什么要配置这个呢，因为提交代码肯定是要拥有你的github权限才行，但直接使用用户名和密码太不安全了，所以使用SSH key来解决本地和服务器连接的问题。在git bush中输入</p><pre><code>$ cd ~/.ssh #检查本机已存在的ssh</code></pre><p>　　如果提示No such file or directory 说明是第一次使用git。</p><pre><code>$ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></pre><p>　　然后连续三次回车，最终生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，打开并复制其中的内容，打开github主页，进入个人设置-&gt;SSH and GPG keys -&gt;New SSH key。将内容粘贴到key中，title随便填，保存。</p><h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><pre><code>$ ssh -T git@github.com</code></pre><p>　　如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p><pre><code>Hi XXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><p>　　配置成功，但还得再配置两条</p><pre><code>$ git config --global user.name &quot;xxx&quot;// 你的github用户名，非昵称$ git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱</code></pre><h1 id="使用——hexo"><a href="#使用——hexo" class="headerlink" title="使用——hexo"></a>使用——hexo</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>$ npm install -g hexo</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>　　在电脑的某个地方新建一个hexo文件夹，例如我在c：\bin\hexo,记住安装位置，常用。</p><pre><code>$ cd /c/bin/hexo/$ hexo init</code></pre><p>　　hexo会自动下载一些文件在这个目录下．接下来：</p><pre><code>$ hexo g # 生成$ hexo s # 启动服务</code></pre><p>　　执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。</p><p>　　hexo s是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 我们将见到我们的第一篇文章，Hello World。</p><p>　　到现在，ｈｅｘｏ博客的搭建已经完成，摩天大楼的基石已经建立，接下来，就是美化，填充，与修缮了，随着本人的学习，hexo博客教程也将接着完善——敬请期待。　　　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;搭建须知&quot;&gt;&lt;a href=&quot;#搭建须知&quot; class=&quot;headerlink&quot; title=&quot;搭建须知&quot;&gt;&lt;/a&gt;搭建须知&lt;/h1&gt;&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
