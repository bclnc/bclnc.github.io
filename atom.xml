<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伏窗尾的猫</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bclnc.github.io/"/>
  <updated>2019-01-04T15:52:52.915Z</updated>
  <id>http://bclnc.github.io/</id>
  
  <author>
    <name>喵呜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git-hexo搭建前传</title>
    <link href="http://bclnc.github.io/2019/01/04/git-hexo%E6%90%AD%E5%BB%BA%E5%89%8D%E4%BC%A0/"/>
    <id>http://bclnc.github.io/2019/01/04/git-hexo搭建前传/</id>
    <published>2019-01-04T06:20:26.000Z</published>
    <updated>2019-01-04T15:52:52.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>此为hexo搭建前传，其为hexo的简易安装做进一步的完善，零基础实现git+hexo个人博客教程。即git账号创建，软件安装，信息配置等信息。</p><h3 id="git账号获取"><a href="#git账号获取" class="headerlink" title="git账号获取"></a>git账号获取</h3><p>首先，百度进入github官网，注册账号。输入名称，邮箱，以及密码。</p><p><img src="//bclnc.github.io/2019/01/04/git-hexo搭建前传/git1.png" alt="git1"></p><p>然后校验是否为人机，创建账号。</p><p><img src="//bclnc.github.io/2019/01/04/git-hexo搭建前传/git1s.png" alt="git1s"></p><p>账号设置，选择免费的。</p><p><img src="//bclnc.github.io/2019/01/04/git-hexo搭建前传/git2.png" alt="git2"></p><p>附加选项不选，一般来说个人的话不需要选择。</p><p><img src="//bclnc.github.io/2019/01/04/git-hexo搭建前传/git3.png" alt="git3"></p><p>至此，账号创建成功。</p><h3 id="git环境搭建"><a href="#git环境搭建" class="headerlink" title="git环境搭建"></a>git环境搭建</h3><p>下载git for windows——直接百度git for windows，然后下载并安装至熟悉位置。</p><p><img src="//bclnc.github.io/2019/01/04/git-hexo搭建前传/gitgui.png" alt="gitgui"></p><p>完成后，会出现git bush，点击，弹出一个类似于命令行的窗口，说明git安装成功！<br>安装完成后，还需要最后一步设置，在命令行输入：</p><blockquote><p>$ git config –global user.name “Your Name”</p><p>$ git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“</p></blockquote><h3 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h3><p>百度node.js,进入官网下载。安装，一路next，直到结束。<br>重启git bush，输入node -v，得到类似结果。<img src="//bclnc.github.io/2019/01/04/git-hexo搭建前传/node1.png" alt="node1">。输入npm -v，也能得到版本号。即安装结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;此为hexo搭建前传，其为hexo的简易安装做进一步的完善，零基础实现git+hexo个人博客教程。即git账号创建，软件安装，信息配置等信
      
    
    </summary>
    
      <category term="hexo" scheme="http://bclnc.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://bclnc.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>自电脑重装所需步骤</title>
    <link href="http://bclnc.github.io/2018/12/15/%E8%87%AA%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85%E6%89%80%E9%9C%80%E6%AD%A5%E9%AA%A4/"/>
    <id>http://bclnc.github.io/2018/12/15/自电脑重装所需步骤/</id>
    <published>2018-12-15T06:57:53.000Z</published>
    <updated>2019-01-04T07:47:07.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="电脑重装"><a href="#电脑重装" class="headerlink" title="电脑重装"></a>电脑重装</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>　　重装系统的第一步就是备份了，记住自己现在电脑有什么是需要保存下来，并且网络上并不好寻找的东西，放置至备份盘中。以下，是自己的备份列表：</p><blockquote><p>git-hexo文件夹（保存了自己所写的博文）</p><p>雨滴桌面资源（可要可不要，资源还是挺好找的）</p><p>图标包资源(win10白色图标包)</p><p>chrome浏览器插件（友范全网通vip/infinity/tampermonkey）</p><p>各式学习软件安装包（Keil uVision5 / Source Insight 4.0 / MATLAB/VMware虚拟机/ubuntu镜像）</p><p>各式实用软件安装包（quick look/memreduct/wise hotkey/snipaste/CCleaner/f.lux/7.zip/pandownload/StartIsBackCfg）</p></blockquote><h3 id="重装"><a href="#重装" class="headerlink" title="重装"></a>重装</h3><p>启动盘——大白菜pe</p><p>系统镜像——win10家庭版</p><p>进入电脑bios，在boot中将首选启动项选择为u盘，注意，在进bios之前将U盘插入，否则无法检测。</p><p>保存设置并启动，进入pe系统，使用磁盘分区助手分盘，选择系统镜像安装。</p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>打开备份软件，逐一安装。</p><p>安全软件 —— 火绒；</p><p>清理软件 —— ccleaner；</p><p>解压软件 —— 7.zip；</p><p>护眼软件 —— f.lux；</p><p>截屏软件 —— snipaste；</p><p>内存清理 —— memreduct；</p><p>快捷键选 —— wise hotkey；</p><p>百度云盘 —— pandownload；</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>git环境见——git环境搭建。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;电脑重装&quot;&gt;&lt;a href=&quot;#电脑重装&quot; class=&quot;headerlink&quot; title=&quot;电脑重装&quot;&gt;&lt;/a&gt;电脑重装&lt;/h2&gt;&lt;h3 id=&quot;备份&quot;&gt;&lt;a href=&quot;#备份&quot; class=&quot;headerlink&quot; title=&quot;备份&quot;&gt;&lt;/a&gt;备份&lt;/h
      
    
    </summary>
    
      <category term="随记" scheme="http://bclnc.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="电脑随记" scheme="http://bclnc.github.io/tags/%E7%94%B5%E8%84%91%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>简易hexo的搭建　　（二）</title>
    <link href="http://bclnc.github.io/2018/12/04/%E7%AE%80%E6%98%93%E7%9A%84hexo%E6%90%AD%E5%BB%BA%E4%BA%8C/"/>
    <id>http://bclnc.github.io/2018/12/04/简易的hexo搭建二/</id>
    <published>2018-12-04T07:31:57.000Z</published>
    <updated>2018-12-06T06:14:19.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="启言"><a href="#启言" class="headerlink" title="启言"></a>启言</h2><p>　　从上一次写hexo到现在已经过去了很长一段时间了，利用next美化界面还没写，真的懒啊，但是呢，今天看到关于域名的一些东西（<strong>其实就是腾讯超便宜的域名让我动心了</strong>），突然想起我还用着github的二级域名，没牌面啊。于是，赶紧买个域名，虽然穷，但是穷有穷的装法不是？话不多说，开始吧。</p><h2 id="垃圾佬的乐趣——便宜域名的获取及设置"><a href="#垃圾佬的乐趣——便宜域名的获取及设置" class="headerlink" title="垃圾佬的乐趣——便宜域名的获取及设置"></a>垃圾佬的乐趣——便宜域名的获取及设置</h2><p>　　用的是腾讯的域名哈，在空间看到的，就不给他打广告了（三块钱买不了吃亏，买不了上当，但是可以很快乐）。　　</p><p>　　买了之后登陆腾讯云，然后找到域名那块地方。如下图：</p><p><img src="//bclnc.github.io/2018/12/04/简易的hexo搭建二/域名设置1.png" alt="域名设置1"></p><p>　　点一下解析，进入第二个界面：</p><p><img src="//bclnc.github.io/2018/12/04/简易的hexo搭建二/域名设置2.png" alt="域名设置2"></p><blockquote><p>添加记录</p><p>主机记录选择: www , @ </p><p>记录类型：CNAME,</p><p>线路类型:默认，</p><p>记录值：就是你的github的库，也就是前文的所写的</p></blockquote><blockquote><p>用户名.github.io</p></blockquote><p>然后，等等，再等等，再等等，（稍微有点久，至少我有点久），直到进域名的时候，弹出github的404页面。证明成功映射到了github网站啦。在等待的时间可以去执行下一步。</p><h2 id="最后的牢骚——hexo本地配置"><a href="#最后的牢骚——hexo本地配置" class="headerlink" title="最后的牢骚——hexo本地配置"></a>最后的牢骚——hexo本地配置</h2><p>打开本地hexo——进入source——创建CNAME文件（不是文件夹，是文件，不带后缀的）——记事本打开——添加域名（不带www，就买的啥样就写啥样）——保存</p><p>打开git bash——进入hexo——gexo clean——hexo g——hexo d。</p><p>然后，然后刷新域名，就搞定了。</p><p>文终。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;启言&quot;&gt;&lt;a href=&quot;#启言&quot; class=&quot;headerlink&quot; title=&quot;启言&quot;&gt;&lt;/a&gt;启言&lt;/h2&gt;&lt;p&gt;　　从上一次写hexo到现在已经过去了很长一段时间了，利用next美化界面还没写，真的懒啊，但是呢，今天看到关于域名的一些东西（&lt;stron
      
    
    </summary>
    
      <category term="hexo" scheme="http://bclnc.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://bclnc.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ARM随记</title>
    <link href="http://bclnc.github.io/2018/11/20/ARM%E9%9A%8F%E8%AE%B0/"/>
    <id>http://bclnc.github.io/2018/11/20/ARM随记/</id>
    <published>2018-11-20T10:41:51.000Z</published>
    <updated>2018-12-06T03:36:27.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h1><h3 id="冯诺依曼结构的计算机有哪些组成部分？"><a href="#冯诺依曼结构的计算机有哪些组成部分？" class="headerlink" title="冯诺依曼结构的计算机有哪些组成部分？"></a>冯诺依曼结构的计算机有哪些组成部分？</h3><p>　　控制器，运算器，存储器，输入设备，输出设备</p><h3 id="冯诺依曼结构和哈佛结构的区别是什么？"><a href="#冯诺依曼结构和哈佛结构的区别是什么？" class="headerlink" title="冯诺依曼结构和哈佛结构的区别是什么？"></a>冯诺依曼结构和哈佛结构的区别是什么？</h3><p>　　而冯.诺依曼结构将指令存储器和数据存储器合在一起的存储器结构；</p><p><img src="//bclnc.github.io/2018/11/20/ARM随记/冯诺依曼结构.png" alt="冯诺依曼"></p><p>　哈佛结构是将指令存储器和数据存储器分开的一种存储器结构；</p><p><img src="//bclnc.github.io/2018/11/20/ARM随记/哈佛结构.png" alt="哈佛">　　</p><h3 id="冯诺依曼结构和哈佛结构相比较，各自的优缺点是什么？"><a href="#冯诺依曼结构和哈佛结构相比较，各自的优缺点是什么？" class="headerlink" title="冯诺依曼结构和哈佛结构相比较，各自的优缺点是什么？"></a>冯诺依曼结构和哈佛结构相比较，各自的优缺点是什么？</h3><p>　　在典型情况下，完成一条指令需要经过三个步骤，取指令，指令译码，执行指令，而冯诺依曼结构的指令存储器和数据存储器在同一存储空间，经由一根总线传输，所以取指令和执行指令不能重叠执行，只能完成一个后再执行下一个。<br><img src="//bclnc.github.io/2018/11/20/ARM随记/冯诺依曼执行.png" alt="冯诺依曼"></p><p>　　而哈佛结构由于取指和执行经由不同的储存空间和总线，使得各条指令能够重叠执行，提高了执行效率。<br><img src="//bclnc.github.io/2018/11/20/ARM随记/哈佛执行.png" alt="哈佛"></p><h3 id="数据总线，地址总线和控制总线"><a href="#数据总线，地址总线和控制总线" class="headerlink" title="数据总线，地址总线和控制总线"></a>数据总线，地址总线和控制总线</h3><p><strong>数据总线（Data Bus）</strong>：</p><p>（1）数据总线是cpu和内存或其他期间之间数据交互的通道（双向）</p><p>（2）数据总线的宽度决定了cpu和外界的传输速度</p><p>（3）每条传输线一次只能传输一位二进制数，也就是说一次可传输数据大小为：2^n</p><p><strong>地址总线（Address Bus）</strong>：</p><p>（1）cpu通过地址总线来指定存储单元进行获取或存入（单向，从cpu传向外部设备或I/O端口）</p><p>（2）地址总线决定了cpu所能访问的最大内存空间的大小2^N,N为地址线数量.</p><p><strong>控制总线（Control Bus）</strong>：</p><p>（1）用来传送控制信号和时序信号（cpu向存储器或其他设备发送的读写信号，中断响应信号等，也有其他设备反馈给cpu的信号）</p><p>（）控制总线的宽度决定了cpu对外部设备的控制能力</p><h3 id="CPU的工作原理"><a href="#CPU的工作原理" class="headerlink" title="CPU的工作原理"></a>CPU的工作原理</h3><p>cpu从逻辑上分为三个部分，<code>控制单元</code>，<code>存储单元</code>和<code>运算单元</code>，这三部分由cpu内部总线连接起来。CPU从内存中一条一条地取出指令和相应的数据，按指令操作码的规定，对数据进行运算处理，直到程序执行完毕为止。</p><p><img src="//bclnc.github.io/2018/11/20/ARM随记/cpu.png" alt="cpu"></p><p><code>**控制单元**</code>:由指令寄存器IR(instruction register)、指令译码器ID(Instruction Decoder)和操作控制器OC(Operation Controller)等组成。根据用户的程序，从存储器中取出指令，放在指令寄存器IR中，然后通过ID译码器分析应该进行什么操作，最后通过控制操作器按时序向相应的不见发送控制信号。</p><p><code>**运算单元**</code>：接受控制单元的命令，进行算数操作。</p><p><code>**存储单元**</code>：包括cpu片内缓存和寄存器组，保存着待处理数据或已经处理过的数据。</p><p>经细化概括后，绘制图示：<br><img src="//bclnc.github.io/2018/11/20/ARM随记/cpu流程.png" alt="cpu"></p><p>总结一下，CPU的运行原理就是：<code>控制单元在时序脉冲的作用下，将指令计数器里所指向的指令地址(这个地址是在内存里的)送到地址总线上去，然后CPU将这个地址里的指令读到指令寄存器进行译码。对于执行指令过程中所需要用到的数据，会将数据地址也送到地址总线，然后CPU把数据读到CPU的内部存储单元(就是内部寄存器)暂存起来，最后命令运算单元对数据进行处理加工。周而复始，一直这样执行下去，天荒地老，海枯枝烂，直到停电。</code></p><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>（1）什么是流水线？</p><p>　　为提高cpu利用率，加快执行速度，将指令分为若干阶段，可并行执行不同指令的不同阶段，从而多个指令同时执行。</p><p>（2）为什么要使用流水线？</p><p>　　提高cpu利用率，提升指令执行速度。</p><p>（3）5级流水线有哪些？</p><p>　　取址，译码/读寄存器、执行/计算有效地址、访问内存（读写）、结果写回寄存器。</p><p>（4）流水线阻塞的原因。</p><p>　　+ 结构相关：硬件资源不足，冲突。</p><p>　　+ 数据相关：一条指令需要前面某条指令的执行结果，而两者并行执行时。</p><p>　　+ 控制相关：有跳转语句，分支指令等。</p><h3 id="指令集介绍"><a href="#指令集介绍" class="headerlink" title="指令集介绍"></a>指令集介绍</h3><p>ARM公司设计的CPU支持多种指令集。</p><p>ARM指令集（32位）</p><p>thumb指令集（16位）<br>　<br>thumb指令集（32位）</p><p>ARM code对应的cpu状态为ARM State；Thumb code对应的cpu状态为thumb状态。如果程序的某一部分工作在ARM状态，一部分工作在Thumb状态，而这两段代码相互调用，则在编译的时候要加上-apcs/interwork选项。</p><h3 id="STM32寄存器介绍。"><a href="#STM32寄存器介绍。" class="headerlink" title="STM32寄存器介绍。"></a>STM32寄存器介绍。</h3><p>通用寄存器：</p><p>R0-R7:thumb和thumb-2均可访问<br>R8-R12:少量thumb可访问，thumb-2都可以访问。</p><p>专用寄存器：<br>R13（sp） R14（LR） R15(PC) xPSR</p><p>R13(SP) stack pointer 堆栈指针，用来保存堆栈的栈顶地址</p><p>　　“堆栈”——后进先出，使用的目的是为了支持函数调用，达到现场保护的目的。</p><p>用ｃ语言来描述，当程序进入某一函数时，操作形参，不改变实参的值，此时形参就是存储在栈区。假设过程Ａ执行过程中调用Ｂ，此时执行会操作寄存器，但是被操作的寄存器可能有Ａ中的重要数据，改变了重要数据，显然是不对的，这时候就需要现场保护了。将寄存器中的数据存储至内存，当调用结束再从内存中将数据加载（load）到寄存器中。</p><p>R14(LR)：linker register 链接寄存器</p><p>保存下一条指令，这指令时保存过程调用后返回的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ARM&quot;&gt;&lt;a href=&quot;#ARM&quot; class=&quot;headerlink&quot; title=&quot;ARM&quot;&gt;&lt;/a&gt;ARM&lt;/h1&gt;&lt;h3 id=&quot;冯诺依曼结构的计算机有哪些组成部分？&quot;&gt;&lt;a href=&quot;#冯诺依曼结构的计算机有哪些组成部分？&quot; class=&quot;head
      
    
    </summary>
    
      <category term="学习之路" scheme="http://bclnc.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="ARM" scheme="http://bclnc.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>笔试常见问题汇总</title>
    <link href="http://bclnc.github.io/2018/10/31/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://bclnc.github.io/2018/10/31/网络编程问题汇总/</id>
    <published>2018-10-31T05:34:25.000Z</published>
    <updated>2018-12-06T03:37:41.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络编程的常见问题"><a href="#网络编程的常见问题" class="headerlink" title="网络编程的常见问题"></a>网络编程的常见问题</h2><h3 id="1、TCP和UDP的区别。"><a href="#1、TCP和UDP的区别。" class="headerlink" title="1、TCP和UDP的区别。"></a>1、TCP和UDP的区别。</h3><hr><p>这是一个超级常见的问题，只要考网络编程就会有，但是实际上想说全比较难，建议写成两行，对比观看就很清楚。</p><p>TCP：面向连接的可靠的字节流服务。用户数据稳定，有序的进行传输，占用资源也多。（关键词，连接，可靠，字节流，稳定有序，占资源）    　　　　</p><p>UDP:无连接，不可靠的用户数据报服务。数据尽可能的高效发送，会丢包，数据传输也可能无序。（关键词，无连接，不可靠，数据报，高效无序，资源损耗少）</p><h3 id="2、多线程是怎么实现同步的。"><a href="#2、多线程是怎么实现同步的。" class="headerlink" title="2、多线程是怎么实现同步的。"></a>2、多线程是怎么实现同步的。</h3><hr><p>这个问题可能是简答题（事件，信号量，互斥锁，），也可能是一个编程题，编程题最常见的就是写两个线程实现交替打印奇数和偶数。就以这个作为例子吧。首先写两个函数，一个打印奇数，一个打印偶数。（用一个全局变量，交替加1就行。）</p><h3 id="3、简述一下socket编程。"><a href="#3、简述一下socket编程。" class="headerlink" title="3、简述一下socket编程。"></a>3、简述一下socket编程。</h3><p>　　socket可以理解成ip+端口，或者说是一组接口。以tcp为例，服务端，创立套接字（socket），绑定ip和端口（bind），监听来自客户端的连接（listen），阻塞至有客户端进行连接请求（accept），连接后直接进行数据传输即可（send，recv）最后关闭套接字。而客户端则需要建立一个同ip及端口的套接字，向服务端发送连接请求（connect），成功后数据交互，关闭套接字。</p><h3 id="4、简述一下三次握手和四次挥手。"><a href="#4、简述一下三次握手和四次挥手。" class="headerlink" title="4、简述一下三次握手和四次挥手。"></a>4、简述一下三次握手和四次挥手。</h3><p>画图是特别好理解的，但是面试的话呢，就行不通了，这时候就得想办法组织语言了。</p><p><strong>tcp的三次握手</strong></p><p>第一次握手：客户端向服务端发起连接请求，同步位SYN=1,seq=x；客户端状态SYN-SENT(同步发送)。</p><p>第二次握手：此时服务端接收到请求，状态由listen变为SYN-RECV,并回复应答包SYN=1,ACK=1，ack=x+1，seq=y。</p><p>第三次握手：客户端接收到服务端的应答包，向服务端发送确认应答包，ACK=1,ack=y+1，seq=z.</p><p><img src="//bclnc.github.io/2018/10/31/网络编程问题汇总/三次握手.png" alt="图示"></p><p><strong>tcp的四次挥手</strong><br>先假设是客户端发起的中断连接请求，这样好描述一些。</p><p>第一次挥手：客户端发出连接释放请求FIN=1,seq=x，并停止数据发送，进入FIN-WAIT-1状态。</p><p>第二次挥手：服务端收到释放请求后发出确认请求报文段，ACK=1,ack=x+1,seq=y,并进入CLOSE-WAIT状态，此时A-B的连接中断。A接收到B的应答包后，进入FIN-WAIT-2状态。</p><p>第三次挥手：客户端没有要发送的数据后，向A发送中断连接请求包，FIN=1,ACK=1,ack=x+1，seq=z。B进入LAST-ACK状态，等待最后的确认。</p><p>第四次挥手：服务端收到中断连接包后，发出确认包，ACK=1,seq=y+1，ack=z+1，A进入TIME-WAIT状态，等待2ms后，进入close状态。<br><img src="//bclnc.github.io/2018/10/31/网络编程问题汇总/四次挥手.png" alt="图示"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络编程的常见问题&quot;&gt;&lt;a href=&quot;#网络编程的常见问题&quot; class=&quot;headerlink&quot; title=&quot;网络编程的常见问题&quot;&gt;&lt;/a&gt;网络编程的常见问题&lt;/h2&gt;&lt;h3 id=&quot;1、TCP和UDP的区别。&quot;&gt;&lt;a href=&quot;#1、TCP和UDP的区别
      
    
    </summary>
    
      <category term="学习之路" scheme="http://bclnc.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="笔试常见问题汇总" scheme="http://bclnc.github.io/tags/%E7%AC%94%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>字符串操作</title>
    <link href="http://bclnc.github.io/2018/10/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
    <id>http://bclnc.github.io/2018/10/25/字符串操作/</id>
    <published>2018-10-24T16:19:43.000Z</published>
    <updated>2018-12-06T03:36:18.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><p>　　最近面试了很多家，都考到了string操作，如strcpy，strcmp等，虽然感觉很简单，但是写的很乱，其实对于笔试是没有任何好处的，尽量的写的严谨，精致。下面总结一下怎么实现这几个函数。</p><h2 id="Strcpy"><a href="#Strcpy" class="headerlink" title="Strcpy"></a>Strcpy</h2><p>　　Strcpy（）这个函数就是用来复制字符串的，拷贝一个字符串，原字符串不能被更改，否则会出错。则被拷贝函数要加上const。所以函数声明为，</p><pre><code>char *Strcpy(char *dst,const char *src);</code></pre><p>为了保证函数的健壮性，要对指针的有效性进行检查，所以要使用assert函数，</p><pre><code>assert（dst !=NULL &amp;&amp; src !=NULL）;</code></pre><p>而后，要保存返回的地址，即dst，而赋值操作要对dst进行移位赋值，所以要定义一个新的指针来进行移位赋值操作。</p><pre><code>char *ret = dst；</code></pre><p>最关键的一步，循环赋值，用while函数</p><pre><code>while（(*ret++ = *src++) ！=&apos;\0&apos;)</code></pre><p>赋值到src 为’\0’,并且’\0’也被赋值，返回值为dst。</p><h2 id="内存重叠"><a href="#内存重叠" class="headerlink" title="内存重叠"></a>内存重叠</h2><p>如果考虑到内存重叠，（即两个字符串有共同区域）可以新开辟一段空间去保存被拷贝函数，然后将保存的值存入要拷贝到的地址，还可以通过逆序拷贝的方式。</p><p>首先还是函数声明</p><pre><code>char *memcpy(char *dst,const char *src，int len)</code></pre><p>健壮性，指针有效性检测</p><pre><code>assert(dst!= NULL &amp;&amp; src != NULL)</code></pre><p>保存首地址char *ret = dst；</p><p>判断是否存在内存重叠，重叠只有一种可能，源字符串的尾部被覆盖，也就是src&lt;= dst&lt;=src+len(len=strlen(src)+1),此时倒叙赋值就好了。这样就避免了重覆盖。没内存重叠的时候就顺序赋值就好了。<br>    if(src&lt;= dst &amp;&amp; dst&lt;=src+len-1)<br>    {<br>        dst=dst+len-1；<br>        src=src+len-1；<br>        while(len–)<br>        {<br>            <em>dst– = </em>src–;<br>        }<br>    }<br>    else<br>    {<br>        while(len–)<br>        <em>dst++ = </em>src++;<br>    }</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串操作&quot;&gt;&lt;a href=&quot;#字符串操作&quot; class=&quot;headerlink&quot; title=&quot;字符串操作&quot;&gt;&lt;/a&gt;字符串操作&lt;/h1&gt;&lt;p&gt;　　最近面试了很多家，都考到了string操作，如strcpy，strcmp等，虽然感觉很简单，但是写的很乱，其实对
      
    
    </summary>
    
      <category term="学习之路" scheme="http://bclnc.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="字符串操作" scheme="http://bclnc.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>链表思考</title>
    <link href="http://bclnc.github.io/2018/10/19/%E9%93%BE%E8%A1%A8%E6%80%9D%E8%80%83/"/>
    <id>http://bclnc.github.io/2018/10/19/链表思考/</id>
    <published>2018-10-19T08:06:40.000Z</published>
    <updated>2018-12-06T03:37:32.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表思考"><a href="#链表思考" class="headerlink" title="链表思考"></a>链表思考</h1><p>链表题能充分的显示出做题者的思维能力，在这就总结一些网络上看到的链表题及个人解法。</p><h3 id="一、判断单链表是否有环。"><a href="#一、判断单链表是否有环。" class="headerlink" title="一、判断单链表是否有环。"></a>一、判断单链表是否有环。</h3><p>　　一个单链表若是有环，则无法从头遍历到尾，可以设置不同步的两个指针从头开始遍历，若相遇则代表有环。比如P1=P1-&gt;next，p2=p2-&gt;next-&gt;next。在拜读某位大牛的博客时，看到一篇文章。可以参考。<br><a href="http://ostermiller.org/find_loop_singly_linked_list.html" target="_blank" rel="noopener">http://ostermiller.org/find_loop_singly_linked_list.html</a></p><h3 id="二、判断两个单链表是否有交点，有的话，找出交点。"><a href="#二、判断两个单链表是否有交点，有的话，找出交点。" class="headerlink" title="二、判断两个单链表是否有交点，有的话，找出交点。"></a>二、判断两个单链表是否有交点，有的话，找出交点。</h3><p>　　判断是否相交有很多方法，想的最简单的就是两个链表如果相交，链表尾肯定是一样的，那么同时遍历到尾，看是否相等就好了。或者利用上面的办法，将其中一个链表的尾只想另一链表头，判断是否有环。画个图理解一下。<img src="//bclnc.github.io/2018/10/19/链表思考/1.png" alt="图例"></p><p>　　两个链表，表头一样，那么直接找到了交点。如果不一样，假设第一个链表长度为len1，第二个为len2，然后找出长度较长的，让长度较长的链表指针向后移动|len1 - len2| (len1-len2的绝对值)，然后在开始遍历两个链表，判断节点是否相同即可。</p><h3 id="三、判断两个单链表是否带环，是的话，找出交点。"><a href="#三、判断两个单链表是否带环，是的话，找出交点。" class="headerlink" title="三、判断两个单链表是否带环，是的话，找出交点。"></a>三、判断两个单链表是否带环，是的话，找出交点。</h3><p>　　这是上述两题的合集，可以先用异步的办法判断是否有环。交点ｐ在环中，然后把环断开，P1=P,P2=P-&gt;next，p-&gt;next=NULL.现在有两个单链表了，一个从head开始，一个从P2开始。利用第二题的办法就能搞定了。</p><h3 id="四、删除单链表的某节点"><a href="#四、删除单链表的某节点" class="headerlink" title="四、删除单链表的某节点"></a>四、删除单链表的某节点</h3><p>　　删除节点不是很简单吗，遍历链表，建立一个循环来找到这个节点r，每次没找到都保存一下上一节点pre，删除的时候只需要pre-&gt;next=r-&gt;next,然后r-&gt;next=NULL,free（r），r=NULL。</p><p>但是这一点都不cool，还要找到上一节点，还得遍历，还得有头节点。很复杂。那么，我们可不可以鸠占鹊巢呢，我们有这个节点p，有这个节点p的下一个节点p-&gt;next,那么，我们把p-&gt;next的数据全部拷贝到p，然后p-&gt;next=p-&gt;next-&gt;next,再干掉p-&gt;next。成功实现功能。<br><img src="//bclnc.github.io/2018/10/19/链表思考/2.png" alt="图例"></p><h3 id="五，在单链表的某节点前插入节点"><a href="#五，在单链表的某节点前插入节点" class="headerlink" title="五，在单链表的某节点前插入节点"></a>五，在单链表的某节点前插入节点</h3><p>　　常规办法，遍历找到某节点的前节点，然后前节点next指向新节点，新节点next指向某节点。</p><p>　　cool点的办法，鸠占鹊巢式，某节点Ｐ后面插入一个新节点，然后把Ｐ的数据复制到新节点中，再给Ｐ赋值（原本新节点的值）。</p><h3 id="六、删除单链表的倒数第k个节点。"><a href="#六、删除单链表的倒数第k个节点。" class="headerlink" title="六、删除单链表的倒数第ｋ个节点。"></a>六、删除单链表的倒数第ｋ个节点。</h3><p>　　p1指向头节点，P2指向头节点后的第k个节点，（写个for循环，p2从头开始，每次循环指向下一个），两个p同时向后步进，直到p2到链表尾。 此时p1就是要删除的节点了，再鸠占鹊巢式删除p1,收工。</p><h3 id="七、链表排序"><a href="#七、链表排序" class="headerlink" title="七、链表排序"></a>七、链表排序</h3><p>　　简单介绍一个排序，快速排序。其主要思想是找一个标杆，这个标杆左边的数据都比它小，右边的都比它大。此时左右两边又成了新的无序链表，对左右两边的链表再递归调用这个函数。实现功能。</p><pre><code>//=============快速排序====================//交换节点void swap(node * a, node * b){    int temp = a -&gt; val;    a -&gt; val = b -&gt; val;    b -&gt; val = temp;}//求中间点node * partion(node * start, node * end){    if(start == end || start -&gt; next == end)    {           return start;    }       //取第一个元素作为基准元素    node * p = start, * q = start, * refer = start;    //从start开始向后进行一次遍历(因为是单链表，无法按从左右向中间遍历的方法)    while(p != end)    {           if(q -&gt; val &lt; refer -&gt; val)         {               p =  p -&gt; next;            swap(p, q);         }           q = q -&gt; next;    }       swap(p, refer);    return p;}//递归void quick_sort(node * start, node * end){    if(start == end || start -&gt; next == end)    {           return;    }       node * mid = partion(start, end);    quick_sort(start, mid);    quick_sort(mid -&gt; next, end);}void quickSort(list mylist){    if((mylist -&gt; next == NULL) || (mylist -&gt; next -&gt; next == NULL))    {        return;    }    node * start = mylist -&gt; next;    node * end = NULL;    quick_sort(start, end);}</code></pre><h3 id="八、链表倒置"><a href="#八、链表倒置" class="headerlink" title="八、链表倒置"></a>八、链表倒置</h3><p>很不幸，在写这篇博客前，并没有好好整理关于链表的知识，导致笔试的时候遇见这题，思维异常的混乱，虽然成功的完成了，但是很多细节没有注意，涂改过多，描述也不清晰，导致了笔试的失败（思路差，描述乱，涂改多，以后尽量的把思路写草稿纸上再填写到答题纸上）。好吧，废话不多说，开始介绍第八个问题，链表倒置。</p><p>　　一开始，我的思路是，建立一个循环，循环的内容是：每次找到原链表的倒数第一个数和倒数第二个数，把它链接到一个新的链表上，然后把原链表的最后一个数删除。直到原链表空。</p><p>　　这样想一点都不cool，而且会给人一种很差劲的感觉，并且，实现起来比较复杂。有一个很好的思想，叫递归。脑子里有一个递归的概念，重复利用。用的时候想成就只有两个数，要做的事就是把这第一个数node，插到最后一个数temp的后面，因为只有两个数，所以，temp=node-&gt;next，所以要做的事就是，temp-&gt;next=node,node-&gt;next=NULL。递归调用这个函数。</p><pre><code>    ListNode* reverse(ListNode *node){    if(node==NULL)    {        return node;    }    if(node-&gt;next==NULL)//跳出    {        return node;    }    ListNode *preNode=reverse(node-&gt;next);    ListNode *temp=node-&gt;next;    temp-&gt;next=node;    node-&gt;next=NULL;    return preNode;}</code></pre><p>其实不递归也能很cool，写一个循环，循环里prev是node的前驱（第一个node没前驱，所以prev的初值为NULL），每次用temp保存node的后继，然后让node的next指向prev（实现了倒序），此时，这个新的关系成为了新的一个链表，与原链表无关。prev成为下一个node的前驱，也就是现在的node，temp成为新的node。继续循环，直到尾节点结束。</p><pre><code>ListNode *Reverse(ListNode *node){    if(node==NULL)    {      return node;    }    ListNode *prev=NULL;    while(node-&gt;next!=NULL)    {      ListNode *tmp=node-&gt;next;      node-&gt;next=prev;      prev=node;      node=tmp;    }}</code></pre><h3 id="九、有序列表合并"><a href="#九、有序列表合并" class="headerlink" title="九、有序列表合并"></a>九、有序列表合并</h3><p>　　常规思路，肯定是慢慢比较咯，取出链表ａ的值，再取出ｂ的值，比较一下，小的插入到新的链表中。很简单嘛，ｃｏｏｌ一点，这种重复的东西，可以递归嘛。</p><p>我们要做的事情是什么呢，找到ａｂ链表中更小的那个数，赋值给一个新的节点result，并返回这个节点。result节点的下一个指向下一个新节点，也就是这个递归函数了，知道ab其中一个为空。</p><pre><code>struct node* result = NULL;    if(a == NULL)        return (b);    else if(b == NULL)        return (a);    if(a-&gt;data &lt;= b-&gt;data)    {        result = a;        result-&gt;next = SortedMerge(a-&gt;next, b);    }    else    {        result = b;        result-&gt;next = SortedMerge(a, b-&gt;next);    }    return (result);</code></pre><h3 id="十、找出链表最中间的数"><a href="#十、找出链表最中间的数" class="headerlink" title="十、找出链表最中间的数"></a>十、找出链表最中间的数</h3><p>龟兔赛跑，兔速度是龟的两倍，当兔跑到终点时，龟就在最中间啦。</p><blockquote><p>p1=p2=head;<br>p1=p1-&gt;next;p2=p2-&gt;next-&gt;next;</p></blockquote><p>文终，希望博主下次看自己博客的时候已经拿到offer了吧。加油~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;链表思考&quot;&gt;&lt;a href=&quot;#链表思考&quot; class=&quot;headerlink&quot; title=&quot;链表思考&quot;&gt;&lt;/a&gt;链表思考&lt;/h1&gt;&lt;p&gt;链表题能充分的显示出做题者的思维能力，在这就总结一些网络上看到的链表题及个人解法。&lt;/p&gt;
&lt;h3 id=&quot;一、判断单链表是
      
    
    </summary>
    
      <category term="学习之路" scheme="http://bclnc.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="数据结构" scheme="http://bclnc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>linux安装arm-linux-gcc交叉编译环境</title>
    <link href="http://bclnc.github.io/2018/10/15/linux%E5%AE%89%E8%A3%85arm-linux-gcc%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://bclnc.github.io/2018/10/15/linux安装arm-linux-gcc交叉编译环境/</id>
    <published>2018-10-15T13:10:14.000Z</published>
    <updated>2018-12-06T03:37:01.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux安装交叉arm-linux-gcc编译环境搭建过程"><a href="#linux安装交叉arm-linux-gcc编译环境搭建过程" class="headerlink" title="linux安装交叉arm-linux-gcc编译环境搭建过程"></a>linux安装交叉arm-linux-gcc编译环境搭建过程</h1><p>linux版本：Ubuntu 12.04，编译器：arm-2014.05</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先简单介绍一下，所谓的搭建交叉编译环境，即安装、配置交叉编译工具链。在该环境下编译出嵌入式Linux系统所需的操作系统、应用程序等，然后再上传到目标机上。</p><p>交叉编译工具链是为了编译、链接、处理和调试跨平台体系结构的程序代码。对于交叉开发的工具链来说，在文件名称上加了一个前缀，用来区别本地的工具链。例如，arm-linux-表示是对arm的交叉编译工具链；arm-linux-gcc表示是使用gcc的编译器。除了体系结构相关的编译选项以外，其使用方法与Linux主机上的gcc相同，所以Linux编程技术对于嵌入式同样适用。不过，并不是任何一个版本拿来都能用，各种软件包往往存在版本匹配问题。</p><p>那么gcc和arm-linux-gcc的区别是什么呢？区别就是gcc是linux下的C语言编译器，编译出来的程序在本地执行，而arm-linux-gcc用来在linux下跨平台的C语言编译器，编译出来的程序在目标机(如ARM平台)上执行，嵌入式开发应使用嵌入式交叉编译工具链。</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>首先将下载好的压缩包存放在ubantu某目录下，解压：</p><blockquote><p>sudo tar -xjvf arm-linux-gcc-2014.tar.bz2 </p></blockquote><p>移动到目标目录：usr/local/arm</p><blockquote><p>sudo cp arm-2014.05 /usr/local/arm</p></blockquote><p>如果没有arm文件夹的话就自己新建一个.</p><blockquote><p>cd /usr/local/arm</p><p>mkdir arm</p></blockquote><p>更改环境变量：</p><blockquote><p>sudo vim /etc/profile</p></blockquote><p>在最后添加</p><blockquote><p>export PATH=$PATH:usr/local/arm/arm-2014.05/bin</p></blockquote><p>在上一命令中，$PATH:后面添加的是安装包解压后的路径，为确保路径的准确性，移动到复制到的目标路径，执行pwd指令，获取准确路径，添加环境变量。</p><p>进入所添加的环境变量的路径：</p><blockquote><p>cd /etc/local/arm/arm-2014.05/bin</p></blockquote><p>建立软链接：</p><blockquote><p>sudo ln -s arm-none-linux-gnueabi-gcc arm-linux-gcc</p></blockquote><p>重启：</p><blockquote><p>sudo reboot</p></blockquote><p>重启后打开终端，检查环境变量是否更改</p><blockquote><p>echo $PATH</p></blockquote><p>如果显示有之前添加的路径，则成功加入环境变量，但不一定成功，还需输入：</p><blockquote><p>which arm-linux-gcc</p></blockquote><p>如果显示的路径与自身路径不符，大致是之前所安装的旧版本，这时，可以进入所显示的路径，删除之前所安装的旧版本。</p><p>而后再次检查：<br>arm-linux-gcc -v</p><p>显示版本为2014.05则安装完成。</p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul><li><p>在此之前，安装包解压的路径可以是任意的，但建议是本文所安装的路径。</p></li><li><p>环境变量的修改有多种方式，本文介绍的是仅当前用户可用的方式，比较安全。想了解其他的安装方式可参考其余大神的作品。</p></li><li><p>让环境变量的路径生效可手动，可重启，由于ubantu中的.bashrc文件的位置千奇百怪，所以在不知道得情况下重启是一个好的选择。</p></li><li><p>手动生效方式:</p></li></ul><blockquote><p>source /root/.bashrc<br>souce/home/xxx/.bashrc</p></blockquote><p>文终。</p><p>- </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux安装交叉arm-linux-gcc编译环境搭建过程&quot;&gt;&lt;a href=&quot;#linux安装交叉arm-linux-gcc编译环境搭建过程&quot; class=&quot;headerlink&quot; title=&quot;linux安装交叉arm-linux-gcc编译环境搭建过程&quot;&gt;
      
    
    </summary>
    
      <category term="学习之路" scheme="http://bclnc.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="linux" scheme="http://bclnc.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>c++学习概述</title>
    <link href="http://bclnc.github.io/2018/10/11/c-%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/"/>
    <id>http://bclnc.github.io/2018/10/11/c-学习概述/</id>
    <published>2018-10-11T02:46:48.000Z</published>
    <updated>2018-12-06T03:36:37.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-类综述"><a href="#c-类综述" class="headerlink" title="c++类综述"></a>c++类综述</h1><p>一个带类的c++伪函数如下：</p><pre><code>&gt;#include&lt;iostream&gt;//头文件using namespace std;//命名空间struct List//定义一个结构体(默认公有：public){    int data;    List *next;}class Date//定义了一个类(默认私有：private){public://公有成员，均可访问    Date(){}//默认构造函数    Date(int y,int m,int d)//带参数的构造函数，使用函数重载                          //函数重载：同作用域，相同的函数名，不同的参数(返回值可不同)    {        this-&gt;y = y;//this指针，一个隐含形参，不知实例对象时用this替代。也可以说this指向对象本身        this-&gt;m = m;//在这里的用法是这个类中的为这个类中的成员变量赋值形参m的值        this-&gt;d = d;    }    Date(int y = 0,int m = 0,int d = 0){}//普通带参的构造函数    Point(const Date&amp; p)//拷贝构造函数,用一个已经存在的对象构建一个新的对象    {                    //不显式声明，会自动生成拷贝构造函数，且为浅拷贝(逐成员赋值)                        //以下为浅拷贝，相当于值传递                        //拷贝函数是对本类类型的常引用        cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;        this-&gt;y = p.x;        this-&gt;m = p.y;        this-&gt;d = p.d;    }    void show()//类内定义成员函数    {        cout &lt;&lt; &quot;Date(&quot;&lt;&lt; y &lt;&lt; &quot;/&quot; &lt;&lt; m &lt;&lt; &quot;/&quot; &lt;&lt; d &lt;&lt; &quot;)&quot; &lt;&lt; endl;    }    void get_year();//类内声明，类外定义成员函数    friend void foo(Date date);//友元函数声明    friend class Student;//声明一个友元类，友元类中的函数均是本类的友元函数private://私有成员，通常只能类内访问    int y;    int m;    int d;    //static 静态成员不是对象成员    static int count;//静态成员变量，存在于静态存储区，仅本文件可见，被所有同类的对象共享    static void get_day();//静态成员函数，不与任何对象相联系，没有this指针，仅能调用静态成员变量和静态成员函数};int Student::count = 0;//静态成员变量的类外初始化，不初始化就是0void foo(Date date)    //一个在Date中声明的友元函数，可直接访问类的私有成员。{                            //是一个定义在类外的普通函数，不属于类    cout &lt;&lt; date.y &lt;&lt; endl;}void Date::get_year()//类外定义成员函数，要带上作用域{    cout &lt;&lt; this.y &lt;&lt; endl;}void swap3(int &amp;a,int &amp;b)//一个普通函数，使用了引用作为参数{                        //调用时直接把变量当作实参即可，这里的形参就成了实参的比个别名    int t;                //引用还可以用作返回值    t = a;    a = b;    b = t;}float &amp;fn2(float r)//它以引用方式返回函数值，好处是不用给返回值开辟一段新的空间{　temp=(float)(r*r*3.14);　return temp;}class Student{public:    Student():birthday(1,1,1)//    {        id = 0;        name = &quot;&quot;;    }    Student(int id,string name,Date birth):id(id),name(name),birthday(birth){}    //初始值列表，用于在对象构造前对值得初始化    //按照声明的顺序初始化    //有常量，有引用，和没有默认构造函数的类类型的成员变量必用    Student(const Student&amp; s)//拷贝构造函数(深拷贝)    {                        //当成员变量是指针时，不能简单的浅拷贝，要给指针指向的对象                            //new一块空间出来保存。而后在析构函数中delate掉。                            //不如此，则会double free。        //this-&gt;name = s.name; //浅拷贝        cout &lt;&lt; &quot;my copy constructor...&quot; &lt;&lt; endl;        int len = strlen(s.name) + 1;        this-&gt;name = new char[len];        memcpy(this-&gt;name,s.name,len);    }    Student&amp; operator=(const Student &amp;s)    //赋值运算符重载    {                                                    cout &lt;&lt; &quot;赋值运算符重载函数&quot; &lt;&lt; endl;//运算符重载:返回类型 operator运算符(参数)        //this-&gt;name = s.name;        if(this != &amp;s)        {            delete []name;            this-&gt;name = new char[strlen(s.name)+1];            strcpy(this-&gt;name,s.name);        }        return *this;    }    ~Student()    {        delete []name;    }//析构函数    void show()    {        cout &lt;&lt; id &lt;&lt; name &lt;&lt; endl;        birthday.show();//类的组合，代码重用    }private:    int id;    string name;    Date birthday;};int main(){    Student s;//调用Student无参数的构造函数    Date date(1999,9,9);//调用Date有参数的构造函数    Student s1(1001,&quot;zhangfei&quot;,date);//调用有参数的student的构造函数    s1.show();//函数重用    Student s2(s1);//调用拷贝构造函数    s2.show();    Student s3;    s3 = s2;//运算符重载    s3.show();    return 0;}</code></pre><p>以上，介绍了几种c++类的相关概念及用法：</p><h2 id="类成员函数："><a href="#类成员函数：" class="headerlink" title="类成员函数："></a>类成员函数：</h2><p>类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。能类内定义和类外定义，类外要加上作用域，用法</p><blockquote><p>类型 类：： 函数名。//类型加上作用域加上函数名</p></blockquote><h2 id="访问修饰符："><a href="#访问修饰符：" class="headerlink" title="访问修饰符："></a>访问修饰符：</h2><blockquote><p>public：公有//struct默认公有</p><p>private:私有//class默认私有</p><p>protected:保护成员</p><p>operator：运算符重载</p></blockquote><p>运算符重载用法</p><blockquote><p>类型 operator运算符（参数）</p></blockquote><h2 id="构造函数-amp-析构函数"><a href="#构造函数-amp-析构函数" class="headerlink" title="构造函数&amp;析构函数"></a>构造函数&amp;析构函数</h2><p>类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</p><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><p>有不带参数的构造函数和带参数的构造函数，通过函数重载实现根据不同的参数来实现调用不同的构造函数。</p><p>带参数的构造函数中还有一种带初值的构造函数，如果有参数则按参数赋值，没有则赋初值，属于默认构造函数，默认构造函数就是不带参数就可以调用的构造函数。</p><p>还有运用初始化列表的构造函数，因为在调用构造函数时有两个阶段，初始化阶段和计算阶段。所有类类型的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。</p><ul><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</li></ul><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>　　将一个对象的内容拷贝给相同的类，<strong>用一个已经存在的对象去初始化另一个对象</strong>，两个对象的类型应该相同。拷贝构造函数参数是本类类型的常引用，如果没有显式声明拷贝构造函数，则会隐式生成，并是浅拷贝，逐成员赋值。 </p><p>　　如果类中有指针类型的成员变量，则需要进行深拷贝，需要new一块与原对象指针所指向的地址空间同等大小的地址空间，并将其内容复制至新的地址，否则在调用析构函数时，将对同一块空间double free,报错。</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。友元函数的原型在类的定义时在原型前加上关键字friend，但是友元函数并不是成员函数。友元类同理，友元类中所有的函数都是原类的友元函数。<br>因为友元函数没有this指针，则参数要有三种情况： </p><ul><li><p>要访问非static成员时，需要对象做参数；</p></li><li><p>要访问static成员或全局变量时，则不需要对象做参数；</p></li><li><p>如果做参数的对象是全局对象，则不需要对象做参数.可以直接调用友元函数，不需要通过对象或指针；</p></li></ul><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>类中有一个很关键的指针，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。this是一个常量指针，指向“这个对象”。改变this指针是错误的行为。常用于使用this区分形参和对象成员变量，也常见于返回值，返回“这个对象”。</p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>类中有一个静态成员的概念，关键字static，不管有多少个对象，静态成员只有一个。静态成员在类的所有对象中是共享的。如果不初始化，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化。</p><p><strong>静态成员变量存储于静态全局区</strong>。</p><p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。</p><p>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。</p><p>静态成员函数有一个类范围，他们不能访问类的 this 指针。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c-类综述&quot;&gt;&lt;a href=&quot;#c-类综述&quot; class=&quot;headerlink&quot; title=&quot;c++类综述&quot;&gt;&lt;/a&gt;c++类综述&lt;/h1&gt;&lt;p&gt;一个带类的c++伪函数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;#include&amp;lt;iostream&amp;g
      
    
    </summary>
    
      <category term="学习之路" scheme="http://bclnc.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="c++" scheme="http://bclnc.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>学习之路——进程与线程（三）</title>
    <link href="http://bclnc.github.io/2018/09/28/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://bclnc.github.io/2018/09/28/学习之路——进程间通信/</id>
    <published>2018-09-28T12:25:38.000Z</published>
    <updated>2018-12-06T03:38:08.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p></p><p style="background-color:rgb(125,255,0)">　　进程间通信有：管道；信号；消息队列；信号量，共享内存，socket通信；<br><a id="more"></a></p><h1 id="1-1管道"><a href="#1-1管道" class="headerlink" title="1.1管道"></a>1.1管道</h1><p>　　实质上就是文件通信，最大的弊端就是效率低，有点事不需要额外的API函数直接使用read，write函数即可。</p><h3 id="1-1-1无名管道：pipe"><a href="#1-1-1无名管道：pipe" class="headerlink" title="1.1.1无名管道：pipe"></a>1.1.1无名管道：pipe</h3><pre><code>头文件： #include &lt;unistd.h&gt;原型： int pipe(int pipefd[2]);功能：创建并打开一个无名管道参数： pipefd 一个数组名 这个数组中有两个int型变量      第0个 存储读的 文件描述符 第1个存储写的文件描述符！返回值： 成功返回0 失败返回-1 </code></pre><p>其在文件系统中没有名字，在创建时必须打开并返回文件描述符。<br>　　pipe在创建时返回两个文件描述符，一读一写。<br>并且具备一下功能：</p><blockquote><p>1、管道有两端 一端读 一端写<br>2、按顺序读取 即可以理解为队列结构！<br>3、内容读取后就没有了 即相当于出队操作<br>4、不支持lseek 偏移文件流<br>5、pipe随着内核持续！ </p></blockquote><p>pipe是全双工的，但要实现同时读写，需要两根管道，一读一写。<br>示例如下：<br>    &gt;   close(pipefd1[0]);//关闭一读<br>        close(pipefd2[1]);//关闭二写<br>        char buf[64] = {0};<br>        write(pipefd1[1],”baba henhao!”,13);//向一写写入数据<br>        read(pipefd2[0],buf,64);读取二读读到的数据<br>        printf(“read success is %s”,buf);</p><p><strong>只有有亲缘关系的进程才能使用无名管道通信。</strong></p><h3 id="1-1-2有管道：fifo"><a href="#1-1-2有管道：fifo" class="headerlink" title="1.1.2有管道：fifo"></a>1.1.2有管道：fifo</h3><pre><code>头文件： #include &lt;sys/types.h&gt;        #include &lt;sys/stat.h&gt;原型： int mkfifo(const char *pathname, mode_t mode);功能：创建一个有名管道参数：  pathname 文件名 包括路径           mode 创建时的权限：0777返回值： 成功返回0 失败返回-1 </code></pre><p>创建后由open打开，打开规则如下：</p><blockquote><p>flags = O_RDONLY :open打开即以阻塞方式只读打开<br>flags = O_WRONLY ：open打开即以阻塞方式只写打开<br>flags = O_RDONLY | O_NOBLOCK: open打开 即以非阻塞方式 只读打开<br>flags = O_WRONLY | O_NOBLOCK: open打开 即以非阻塞方式 只写打开</p></blockquote><p>删除一个有名管道：</p><pre><code>&gt;原型：int unlink(const char *path); 参数： path 带路径的文件名</code></pre><p>FIFO是在pipe的基础上给管道添加了个名字，真实存在，可以被多个进程打开读写，内核不会将数据写入到文件中，而是保存在内核，所以FIFO文件中没有内容，通常情况下，打开一端会阻塞，直到另一端打开才会成功。</p><blockquote><p>阻塞方式：<br>　　阻塞的读或者写：<br>　　读时： 如果没有数据 则read阻塞 //即等待数据到来<br>　　写时： 如果没有空间 则write阻塞 //即等待有空间 即另一方读完后再写<br>非阻塞的方式：<br>　　以非阻塞的方式读写<br>　　读时： 如果没有数据 就立即返回 read返回0  并设置响应的错误码！<br>　　写时： 如果没有空间 就立即返回 write返回0 并设置相应错误码！<br>打开：<br>　　只读打开： 总会打开！<br>　　只写打开：只有当只读打开了读端 才能打开写端！</p></blockquote><h2 id="1-2-信号"><a href="#1-2-信号" class="headerlink" title="1.2 信号"></a>1.2 信号</h2><p>signal：实现IPC的一种方式，<strong>本身不会传输数据！</strong>意思就是，给你一个眼神，你自己体会！</p><h3 id="1-2-1信号的实现"><a href="#1-2-1信号的实现" class="headerlink" title="1.2.1信号的实现"></a>1.2.1信号的实现</h3><p>　　就是中断，当一个进程收到某个信号时，内核打断这个进程的执行，转到内核中，查看信号对应的信号处理函数，然后去执行对应的信号处理函数，再返回内核，清除信号，返回断点。</p><p>信号的处理方式：</p><blockquote><p>1、SIG_IGN: ignore 忽略该信号</p></blockquote><p>注意： 有两个信号不能被忽略 SIGKILL 杀死信号    SIGSTOP 停止信号 </p><blockquote><p>原因：这是从外部结束进程的唯一方式！也是系统维护的一种方式！</p></blockquote><p>2、SIG_DFL: default 采用操作系统默认的处理方式<br>默认处理方式 一般有三种：<br>Term: 中止进程<br>Core: 将进程使用的物理资源线 dump 出来 再终止！<br>Ign: 忽略信号 </p><blockquote><p>3、捕获信号<br>即 用户收到某个信号时，这个信号的处理方式用户程序自己决定<br>也就是把一个信号 与一个信号处理函数关联起来的这个过程称之为信号捕获！</p></blockquote><p>以上，看似把信号搞得很复杂，其实真的很复杂，只是作为初学者的我搞不懂，也没必要搞懂，看函数就好了。函数如下：</p><h3 id="1-2-2信号的API函数"><a href="#1-2-2信号的API函数" class="headerlink" title="1.2.2信号的API函数"></a>1.2.2信号的API函数</h3><p>改变信号的处理方式：</p><pre><code>头文件： #include &lt;signal.h&gt;原型： sighandler_t signal(int signum, sighandler_t handler);功能：用来将一个指定的信号 与一个信号处理函数关联起来！参数: signum 信号的值     handler 指向信号处理函数的指针 即函数名！返回值： 返回上一次给信号处理的方式！</code></pre><p>其实相当于跳转，收到某个信号，跳转执行另一个函数，这个函数 必须为void 函数名（int signal）；</p><p>等待一个信号<br>    &gt;头文件： #include &lt;unistd.h&gt;<br>    原型： int pause(void);<br>    功能：使调用该函数的进程或者线程 进入等待模式！即阻塞等待一个信号的出现！<br>    参数：无；<br>    返回值： 该函数仅在捕获到信号并返回信号处理函数时返回-1  并且 ERRNO 被设置为 EINTR<br>            表示：已捕获到信号并处理完成！<br>发送一个信号<br>    &gt;头文件： #include &lt;sys/types.h&gt;</p><pre><code>         #include &lt;signal.h&gt;原型： int kill(pid_t pid, int sig);功能：向指定的进程或者进程组 发送一个指定信号参数: pid，制定的信号接收者      &gt;0  表示指定的信号      =0  表示该进程同组的所有进程     ==-1 发送给有权发送的所有进程      &lt;-1 表示看不懂，不解释     sig：指定的信号，一个整数，比如9就是杀死。返回值： 成功返回0 ，失败返回-1</code></pre><h2 id="1-3-system-V-IPC通信"><a href="#1-3-system-V-IPC通信" class="headerlink" title="1.3 system V IPC通信"></a>1.3 system V IPC通信</h2><blockquote><p>system V msg: 即消息队列<br>system V sem:即信号量<br>system V shm:共享内存</p></blockquote><p>双数三种机制称之为system V IPC,源于system V unix， 原理均为在内核中开辟一块空间，进程通过该空间读写数据实现通信，不使用文件系统的API函数。</p><blockquote><p>函数汇总：<br>　　　　　　　　　　　    消息队列　　　　　　　信号量：　　　　　　共享内存<br>　　头文　　　　　　　sys/msg.h　　　　　　ys/sem.h    　　　　　　sys/shm.h</p></blockquote><pre><code>创建或打开IPC        msgget()            　semget()        　　shmget()      ***get()控制IPC操作    　　　msgctl()        　　　semctl()        　　　shmctl()      ***ctlIPC操作函数　　    msgsnd/msgrcv　　　　　　semop        　    shmat/shmdt</code></pre><p>实现方式：<br>1、申请钥匙 KEY<br>    KEY代表一个唯一一个system V IPC 的对象。</p><pre><code>&gt;头文件： #include &lt;sys/types.h&gt;         #include &lt;sys/ipc.h&gt;原型： key_t ftok(const char *pathname, int proj_id);功能：用来生成一个唯一的System V IPC对象的KEY!参数: pathname 一个已经存在的路径     proj_id 一个整数标志返回值： 成功返回一个 键key_t类型！        失败返回-1 同时 errno被设置！</code></pre><p>P1与P2要进行通信，KEY要相同，即路径与整数标志相同。<br>P3与P4通信，KEY与P1P2的KEY不能相同，容易出问题。不深究，别那么用就好了。</p><h3 id="1-3-1-消息队列"><a href="#1-3-1-消息队列" class="headerlink" title="1.3.1 消息队列"></a>1.3.1 消息队列</h3><p>第一步，创建钥匙</p><blockquote><p>int key = ftok(path,id);</p></blockquote><p>第二步  创建一个消息队列<br>    &gt;原型：int msgget(key_t key, int msgflg);<br>    &gt;参数：key：申请的钥匙<br>          msgflg：标志位<br>            创建：IPC_CREAT|0777<br>            打开：0<br>    返回值：成功返回一个id，标记消息队列<br>           失败返回-1，错误存放error    </p><blockquote><p>实例：int id = msgget(key,IPC_CREAT|0777);</p></blockquote><p>第三步  给消息队列的结构体分配空间</p><blockquote><p>Msg<em> msg1 = (Msg</em>) malloc(sizeof(Msg)+22);</p></blockquote><p>结构体如下：</p><blockquote><p>typedef struct msg{<br>　　struct msg *next ;//指向下一个消息<br>　　int type;//类型<br>    　　long msgtype;//长度<br>    　　char msg_txt[0];//内容<br>}Msg;</p></blockquote><p>其中，<strong>msg_txt[0]为柔性数组，代表可控大小的缓冲区，分配空间时，malloc（结构体+size），size就是柔性数组的实际大小。</strong></p><p>第四步 给结构体内容赋值</p><p>　　结构体就不过多解释了，就结构体内容赋值就好了，再加入到消息队列当中。</p><p>第五步    读写</p><p>发送：<br>    &gt;原型：int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);<br>    &gt;功能：发送消息<br>    &gt;参数： msqid  消息id<br>           msqp   要发送的结构体<br>           msqsz  大小<br>           msqflg 标志 0阻塞，IPC_NOWAIT非阻塞<br>    返回值：成功0 ，失败-1</p><blockquote><p>实例：msgsnd(id,msg1,22,0);</p></blockquote><p>接收：<br>    &gt;原型：ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);<br>    &gt;功能：接收消息<br>    &gt;参数： msqid  消息id<br>           msqp   要发送的结构体<br>           msqsz  大小<br>           msgtyp 消息的类型 如果类型不匹配将会过滤不接受！<br>           msqflg 标志 0阻塞，等待信息来<br>                      IPC_NOWAIT非阻塞，没有就开溜<br>    返回值：成功返回实际读取到的字节数 ，失败-1</p><blockquote><p>实例：msgrcv(id,msg1,22,10086,0);</p></blockquote><p>第六步 关闭<br>    &gt;原型：ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);<br>    &gt;功能：控制消息队列<br>    &gt;参数： msqid  消息id<br>    &gt;　　　cmd 控制的命令 ：<br>    &gt;　　　　　IPC_RMID 删除消息队列<br>    &gt;　　　　　IPC_SET 设置消息队列属性<br>                                　　　　　IPC_STAT 返回消息队列属性 </p><pre><code>&gt;　　　buf 根据 cmd确定 &gt;　　　如果是 IPC_RMID 则填写NULL&gt;　　　如果是 IPC_SET 则为设置属性的结构体指针 &gt;　　　如果是 IPC_STAT 则为读取时 将存储属性的结构体指针 &gt;返回值： 成功返回0 失败返回-1 </code></pre><blockquote><p>实例：msgctl(id,IPC_RMID,NULL);</p></blockquote><h3 id="1-3-2-共享内存"><a href="#1-3-2-共享内存" class="headerlink" title="1.3.2 共享内存"></a>1.3.2 共享内存</h3><h3 id="1-3-2-1-原理"><a href="#1-3-2-1-原理" class="headerlink" title="1.3.2.1 原理"></a>1.3.2.1 原理</h3><p>　　<strong>在内核或者设备内存中开辟一块空间 进程A 可以将这块内存映射到自己的进程空间 那进程B也可以将这段空间映射到自己的地址空间 那么如果A 修改了 这个空间的内容，就对应的修改了B中的内容！    </strong></p><p>###3.2.2API函数<br>第一步创建钥匙（fork函数）</p><p>第二步 创建或打开一个共享内存（shmget函数）</p><pre><code>头文件：#include &lt;sys/ipc.h&gt;       #include &lt;sys/shm.h&gt;原型：int shmget(key_t key, size_t size, int shmflg);参数： key: 获取的钥匙       size 共享内存的大小 必须为 页的整数倍  一页即4k 4096字节       shmflg 标志位         1、创建            IPC_CREAT | 权限位         2、 0 打开 返回值： 成功返回共享内存的id 失败返回-1 错误被存放于errno !</code></pre><blockquote><p>实例：<br>shmget(SEM_SHM_key,4096,IPC_CREAT | 0664);</p></blockquote><p>第三步 映射（shmat函数）</p><pre><code>头文件：#include &lt;sys/types.h&gt;       #include &lt;sys/shm.h&gt;原型：void *shmat(int shmid, const void *shmaddr, int shmflg);参数： shmid:共享内存的id     shmaddr 指定要映射到那一块地址上             如果我不知道怎么办？就写NULL 由操作系统自行分配     shmflg 映射标志         1、SHM_RDONLY 只读映射        2、0 读写 返回值： 成功返回映射区域的首地址 失败返回 NULL 错误存放在 errno</code></pre><blockquote><p>char<em>data_p=(char</em>)shmat(DATA_SHM_id,NULL,0);</p></blockquote><p>第四步 操作（shmctl函数）</p><pre><code>头文件：#include &lt;sys/ipc.h&gt;       #include &lt;sys/shm.h&gt;原型：int shmctl(int shmid, int cmd, struct shmid_ds *buf);参数： shmid 共享内存id        cmd 操作指令             IPC_RMID 删除     buf         当 cmd == IPC_RMID 时写NULL返回值： 成功返回 0 失败返回-1 错误存放在errno </code></pre><p>第五步 解映射（shmdt函数）</p><pre><code>int shmdt(const void *shmaddr);</code></pre><p>但是由于共享内存以及时间片轮转的问题，可能导致数据在写入时产生冲突，所以需要对共享内存的资源进行保护。引入信号量的概念。</p><h2 id="3-3-信号量"><a href="#3-3-信号量" class="headerlink" title="3.3 信号量"></a>3.3 信号量</h2><p><strong>信号量是一种用来提供给不同进程或一个进程之间不同线程进行同步机制的一种手段。</strong></p><p>信号量只为保护共享资源而存在。传说中的骑士精神。厕所大妈==信号量，厕所==共享内存，a，b为不同的进程。大妈要知道有几个厕所，a去上厕所，大妈说ok去吧，还有位置。b来了，也要上厕所，大妈说，不行，有人了，你等一会儿。a出来了，b才能进去。很粗俗，也容易懂。</p><p>###3.3.1 API函数<br>创建信号量</p><pre><code>头文件：#include &lt;sys/types.h&gt;       #include &lt;sys/ipc.h&gt;       #include &lt;sys/sem.h&gt;原型：int semget(key_t key, int nsems, int semflg);参数： key : 获取的钥匙      nsems: 信号量集中包括的信号量的个数     如果不要创建信号量集只要打开 这个参数的值应该为0 一旦创建该值不可更改！   semflg: 标志         1、创建 IPC_CREAT | 权限位         2、打开 0 返回值： 成功返回信号量集的id(sem_t类型),失败返回-1 错误存储在 errno</code></pre><p>实例：</p><blockquote><p>sem_tsem_shm_p=(sem_t)semget(SEM_SHM_id,NULL,0); </p></blockquote><p>###3.3.2 PV操作<br>    头文件：#include &lt;sys/types.h&gt;</p><pre><code>#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;struct sembuf{unsigned short sem_num; /指哪一个信号量short    sem_op;      信号量的操作 是一个 有符号的short类型      即做了相关操作后 semval = 原semval + sem_op     sem_op &gt;0 表示 V 操作 一般会置为   +1 ！     ste_op &lt;0 表示 P操作 一般会置为    -1     ste_op ==0 自己尝试 看看是否就会阻塞！short    sem_flg;     操作标志：    0 表示默认     IPC_NOWAIT 非阻塞         如果是P操作 信号量没有获取到则直接走人 返回-1 表示不能获取！    SEM_UNDO 撤销 这个标志意义重大！        为了防止进程带锁退出 如果设置了这个标志         内核会额外的记录该进程的PV 操作 当进程退出时 会还原！}原型：int semop(int semid, struct sembuf *sops, unsigned nsops);参数： semid 信号量集id     sops: 操作选择的结构体指针    nsops:对几个信号量进行PV 表示有多少个信号量进行PV 操作 一般写一个1 ！返回值：成功返回0 失败返回-1 </code></pre><p>临界区： 对于共享资源的操作指令称之为临界区！</p><p>其实pv操作的意思很简单，信号量一般初始值为1，进行一次p操作，初始值变为0，进入临界区，此时其他进程无法对该共享区域进行操作，直到再进行一次v操作，将信号量还原为1，其他进程才能进行操作。</p><p>所以一次正常的共享内存的进程间通信需要以下几个步骤<br>第一步：创建钥匙（共享内存和信号量两个钥匙）（ftok函数）<br>第二步：创建一个共享内存（shmget函数）<br>第三步：映射（shamt函数）<br>第四步：创建信号量（semget函数）<br>第五步：p操作（op.sem_op = -1;op.sem_flg = SEM_UNDO）（semop函数）<br>第六步：临界区操作（对共享内存操作）<br>第七步：v操作（op.sem_op = 1;）（semop函数）</p><h2 id="3-4-POSIX"><a href="#3-4-POSIX" class="headerlink" title="3.4 POSIX"></a>3.4 POSIX</h2><p><strong>编译要加 -pthread</strong></p><h3 id="3-4-1-有名和无名信号量"><a href="#3-4-1-有名和无名信号量" class="headerlink" title="3.4.1 有名和无名信号量"></a>3.4.1 有名和无名信号量</h3><p><strong>有名信号量</strong>：可以用于 进程间 以及同进程的多个线程间通信 互斥资源。在文件系统中有一个入口  信号量却存在内核中 随着内核持续！ 既可以应用于任意进程 也可以用于线程！<br><strong>无名信号量</strong>：没有名字 基于内存信号量 表示信号量在内存中 这个信号量仅存在某个进程的地址空间 ，可用于同进程的线程间通用。如果，无名信号量存在于进程共享的内存空间则可用于 进程间通信！</p><h3 id="3-4-1-API函数"><a href="#3-4-1-API函数" class="headerlink" title="3.4.1 API函数"></a>3.4.1 API函数</h3><p>创建有名信号量：</p><pre><code>头文件：#include &lt;fcntl.h&gt;                  #include &lt;sys/stat.h&gt;              #include &lt;semaphore.h&gt;原型：sem_t *sem_open(const char *name, int oflag);     sem_t *sem_open(const char *name, int oflag,mode_t mode, unsigned int value);参数： name 表示信号量的名字 必须包括路径 且是绝对路径 //注意：必须以/开头 并且 只能有一个 / 后面就是文件名    oflag 标志位     0 默认 即打开     O_CREAT 创建  后续可以跟的测试参数同 open     mode 创建的权限 同open     value 信号量的初始值 返回值： 成功返回sem_t的一个指针 指向这个信号量         失败 返回 SEM_FAILED 同时 errno被设置 </code></pre><p>创建一个无名信号量 ：</p><pre><code>头文件：#include &lt;semaphore.h&gt;原型 ：int sem_init(sem_t *sem, int pshared, unsigned int value);参数 ：sem:创建无名信号量需要定义一个 sem_t的指针 或者变量  表示存储信号量的地址    指针： 即malloc     变量 ： &amp;变量名 就是其参数 ！pshared: 该无名信号量的共享方式     0 进程内部的线程共享 sem指向的地址是进程的内部地址    1 不同进程间共享         如果是这种情况 要保证sem指向的内存 不同进程都要访问到         那么sem指向的内存必须是 共享内存！value:信号量的值返回值： 成功返回0 失败返回-1  errno被设置 </code></pre><p>删除有名信号量：int sem_unlink(const char <em>name);<br>删除无名信号量：int sem_unlink(const char </em>name);</p><h2 id="3-4-2-PV操作"><a href="#3-4-2-PV操作" class="headerlink" title="3.4.2 PV操作"></a>3.4.2 PV操作</h2><p>p操作：</p><pre><code>#include &lt;semaphore.h&gt;int sem_wait(sem_t *sem);功能： sem_wait 用来获取参数sem所指定的信号量 阻塞直到获取到信号量 或者出错    才会返回！    获取到 返回 0    错误 返回-1int sem_trywait(sem_t *sem);功能：sem_trywait 用来获取sem指定的信号量 即非阻塞方式获取 成功返回0 表示获取到失败直接立马返回 此时返回-1 </code></pre><p>v操作：<br>    &gt;int sem_post(sem_t *sem);<br>    功能： 对指定的信号量进行V操作 </p><p>文终。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程间通信&quot;&gt;&lt;a href=&quot;#进程间通信&quot; class=&quot;headerlink&quot; title=&quot;进程间通信&quot;&gt;&lt;/a&gt;进程间通信&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;background-color:rgb(125,255,0)&quot;&gt;　　进程间通信有：管道；信号；消息队列；信号量，共享内存，socket通信；&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习之路" scheme="http://bclnc.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="进程与线程" scheme="http://bclnc.github.io/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>学习之路 —— 进程与线程　　（二）</title>
    <link href="http://bclnc.github.io/2018/09/20/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B/"/>
    <id>http://bclnc.github.io/2018/09/20/学习之路——进程/</id>
    <published>2018-09-20T05:58:20.000Z</published>
    <updated>2018-12-06T03:38:01.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、进程函数"><a href="#一、进程函数" class="headerlink" title="一、进程函数"></a>一、进程函数</h1><p></p><p style="background-color:rgb(125,255,0)">　　进程——进程是独立功能的程序关于某个数据集合上的一次运行活动！<br><a id="more"></a></p><h2 id="1-1-创建进程函数"><a href="#1-1-创建进程函数" class="headerlink" title="1.1 创建进程函数"></a>1.1 创建进程函数</h2><pre><code>头文件： #include &lt;unistd.h&gt;原型： pid_t fork(void);功能：创建一个进程 返回值：子进程 返回0 父进程 返回子进程的ID </code></pre><p>fork简介：fork函数创建了一个新的进程，新的进程即子进程将复制父进程所有的数据与指令，子进程拥有独立的内存空间以及系统资源。</p><p>问题一：fork 成功后子进程从哪里开始执行？</p><p>　　从调用完fork后面的语句处开始执行！</p><p>问题二：父子进程的执行顺序是怎样的？</p><p>　　由时间片轮转调度决定，没有固定的执行顺序。</p><p>问题三：什么是时间片？</p><p>　　时间片：为实现并发，每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。若时间片结束进程还在运行，则cpu将被剥夺并分配给另一个进程，若进程在时间片结束前阻塞或结束，则cpu当即切换。系统内进程按时间顺序排成一个队列，每次调度，系统都将cpu分配给队内首进程，此进程用完它的时间片后被移动到队列的末尾，接着下一个执行。<br>　　时间片过短：导致过多的进程切换，降低效率。<br>　　时间片过长：引起对短的交互请求响应变差。</p><h2 id="1-2-获取标识码函数"><a href="#1-2-获取标识码函数" class="headerlink" title="1.2 获取标识码函数"></a>1.2 获取标识码函数</h2><pre><code>头文件： #include &lt;unistd.h&gt;        #include &lt;sys/types.h&gt;原型： pid_t getpid(void); //获取本身ID       pid_t getppid(void);//获取父进程ID 功能：获取进程号 返回值：返回所获取的PID</code></pre><h2 id="1-3-进程退出函数"><a href="#1-3-进程退出函数" class="headerlink" title="1.3 进程退出函数"></a>1.3 进程退出函数</h2><p>exit:</p><pre><code>头文件：#include&lt;stdlib.h&gt;原型：void exit(int status)；功能：用来退出进程，进行清除操作参数： 退出码，stasus用来存返回值。</code></pre><p>_exit:</p><pre><code>头文件：#include&lt;unistd.h&gt;原型：void _exit(int status);功能：用来退出进程，立即退出参数： 退出码，stasus用来存返回值。</code></pre><p>_Exit:</p><pre><code>头文件：#include&lt;stdlib.h&gt;原型：void _Exit(int status);功能：用来退出进程，立即退出参数： 退出码，stasus用来存返回值。</code></pre><p>进程死亡：自杀与被杀。自杀：自然死亡与调用退出函数。<br>思考：<br>问题一：return和exit有什么区别？</p><p>a.exit是一个函数，有参数。exit执行完后把控制权交给系统。 </p><p>b.return是函数执行完后的返回。renturn执行完后把控制权交给调用函数。</p><p>问题二：exit与_exit有什么异同？</p><p>相同点：都是用来终止进程的，执行这两个函数时，系统无条件终止所有操作，清除数据，终止进程运行。<br>不同点：_exit执行后立即返回给内核，exit先执行一些清除操作再将控制权交给内核。<br>清除操作：刷新流（stdin，stdout …）,将缓冲区的数据处理完成。</p><p>c.通过实例来区别<br>实例1：exit.c</p><blockquote><p>1 #include “stdio.h”<br>2 #include “stdlib.h”<br>3<br>4 int main()<br>5 {<br>6 printf(“using exit—-\n”);<br>7 printf(“This is the content in buffer”);<br>8 exit(0);<br>9 } </p></blockquote><p>执行结果：</p><blockquote><p>using exit—-<br>This is the content in buffer</p></blockquote><p>实例2：_exit.c</p><blockquote><p>1 #include”stdio.h”<br>2 #include”unistd.h”<br>3<br>4 int main(void)<br>5 {<br>6 printf(“using _exit–\n”);<br>7 printf(“This is the content in buffer”);<br>8 _exit(0);<br>9 }</p></blockquote><p>执行结果：</p><blockquote><p>using exit—-</p></blockquote><p>printf函数就是使用缓冲I/O的方式，该函数在遇到“\n”换行符时自动的从缓冲区中将记录读出。所以exit()将缓冲区的数据写完后才退出，而_exit()函数直接退出。 </p><h2 id="1-4等待子进程结束函数"><a href="#1-4等待子进程结束函数" class="headerlink" title="1.4等待子进程结束函数"></a>1.4等待子进程结束函数</h2><p>wait:</p><pre><code>头文件：#include &lt;sys/types.h&gt;       #include &lt;sys/wait.h&gt;原型：pid_t wait(int *status);功能：等待任意一个子进程状态改变参数： 退出码，stasus用来存子进程返回值。返回值：成功返回 等待到的子进程进程号    失败返回-1 同时errno被设置</code></pre><p>waitpid    :</p><pre><code>头文件：#include &lt;sys/types.h&gt;       #include &lt;sys/wait.h&gt;原型：pid_t waitpid(pid_t pid, int *status, int options);功能：等待任意一个子进程状态改变参数： pid :指定要等待的进程号     stasus :用来存子进程返回值。    options :等待模式：0 表示默认选项 阻塞等待                WNOHANG 非阻塞等待 假设此时没有子进程退出就立刻返回 不用等待！返回值：成功返回 等待到的子进程进程号       失败返回-1 同时errno被设置</code></pre><p>退出码解析：status用来保存子进程的退出状态的信息，用以下宏来解析。</p><p>WIFEXITED（status） ：如果为真，子进程正常退出。</p><p>WEXITSTATUS (status) ：返回子进程的退出码<br>正常退出 main函数的返回值或者exit _Exit _exit 的参数<br>WIFSIGNALED （status） ：如果为真则表示这个子进程是被一个信号干掉的！<br>WCONTINUED （status）  ：如果为真表示 这个子进程是被信号唤醒的！</p><h1 id="二、exec函数族"><a href="#二、exec函数族" class="headerlink" title="二、exec函数族"></a>二、exec函数族</h1><p></p><p style="background-color:rgb(125,255,0)">　　让另外一个程序文件的数据和指令集合 替换 之前拷贝的数据指令！注意这里的替换只能替换 用户数据和指令 系统数据无法替换！</p><p>如图所示：<img src="//bclnc.github.io/2018/09/20/学习之路——进程/exec函数族.png" alt="进程状态"></p><h2 id="1-1综述exec函数族"><a href="#1-1综述exec函数族" class="headerlink" title="1.1综述exec函数族"></a>1.1综述exec函数族</h2><pre><code>&gt;头文件：#include &lt;unistd.h&gt;原型：#include &lt;unistd.h&gt;extern char **environ;int execl(const char *path,const char *arg, ...);int execlp(const char *file, const char *arg, ...);int execle(const char *path,const char *arg,..., char * const envp[]);int execv(const char *path,char *const argv[]);int execvp(const char *file, char *const argv[]);int execve(const char *file,char *const argv[],char *const envp[]);功能： exec函数族装入并运行程序path/file，并将参数arg0(arg1, arg2, argv[], envp[])传递给子程序参数： path :要运行的程序       arg  :存放参数。返回值：出错返回-1，</code></pre><p>l：list：希望接收到以逗号分隔的参数列表，列表以NULL指针作为结束标志。<br>　　　　　把要执行的那个程序文件的参数，以list的形式输出。<br>v：vector：希望接收到一个以NULL结尾的字符串数组的指针（char* argv[]）<br>　　    　　　把要执行的程序文件的参数 以向量即数组的方式出现<br>p:path：环境变量：整个系统中任何一个进程都可以访问的变量。<br>　　　　　一个以NULL结尾的字符串数组指针，函数可以DOS的PATH变量查找子程序文件<br>e:envp：函数传递指定参数envp，允许改变子进程的环境，无后缀e时，子进程使用当前程序的环境。<br>是不是看的头皮发麻？实践出真知。实例如下：</p><h2 id="2-1-头文件及字符串数组指针的声明"><a href="#2-1-头文件及字符串数组指针的声明" class="headerlink" title="2.1 头文件及字符串数组指针的声明"></a>2.1 头文件及字符串数组指针的声明</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;int main(int argc, char *argv[]){  //以NULL结尾的字符串数组的指针，适合包含v的exec函数参数  char *arg[] = {&quot;ls&quot;, &quot;-a&quot;, NULL};｝</code></pre><h2 id="2-2-创建子进程并调用函数execl"><a href="#2-2-创建子进程并调用函数execl" class="headerlink" title="2.2 创建子进程并调用函数execl"></a>2.2 创建子进程并调用函数execl</h2><ul><li><p>execl 中希望接收以逗号分隔的参数列    表，并以NULL指针为结束标志</p><p>  if( fork() == 0 )<br>  {</p><pre><code>// in clild printf( &quot;1------------execl------------\n&quot; );if( execl( &quot;/bin/ls&quot;, &quot;ls&quot;,&quot;-a&quot;, NULL ) == -1 ){  perror( &quot;execl error &quot; );  exit(1);}</code></pre><p>  }</p></li></ul><h2 id="2-3-创建子进程并调用函数execv"><a href="#2-3-创建子进程并调用函数execv" class="headerlink" title="2.3 创建子进程并调用函数execv"></a>2.3 创建子进程并调用函数execv</h2><ul><li>execv中希望接收一个以NULL结尾的字符串数组的指针<pre><code>if( fork() == 0 ){  printf(&quot;2------------execv------------\n&quot;);  if( execv( &quot;/bin/ls&quot;,arg) &lt; 0)  {    perror(&quot;execv error &quot;);    exit(1);  }}</code></pre></li></ul><h2 id="2-4-创建子进程并调用-execlp"><a href="#2-4-创建子进程并调用-execlp" class="headerlink" title="2.4 创建子进程并调用 execlp"></a>2.4 创建子进程并调用 execlp</h2><ul><li>l 　希望接收以逗号分隔的参数列表，列表以NULL指针作为结束标志</li><li><p>p　是一个以NULL结尾的字符串数组指针，函数可以DOS的PATH变量查找子程序文件</p><pre><code>if( fork() == 0 ){  printf(&quot;3------------execlp------------\n&quot;);  if( execlp( &quot;ls&quot;, &quot;ls&quot;, &quot;-a&quot;, NULL ) &lt; 0 )  {    perror( &quot;execlp error &quot; );    exit(1);  }}</code></pre></li></ul><h2 id="2-５-创建子里程并调用execvp"><a href="#2-５-创建子里程并调用execvp" class="headerlink" title="2.５ 创建子里程并调用execvp"></a>2.５ 创建子里程并调用execvp</h2><ul><li>v 　望接收到一个以NULL结尾的字符串数    组的指针</li><li><p>p　 是一个以NULL结尾的字符串数组指针，函数可以DOS的PATH变量查找子程序文件</p><pre><code> if( fork() == 0 ){   printf(&quot;4------------execvp------------\n&quot;);   if( execvp( &quot;ls&quot;, arg ) &lt; 0 )   {     perror( &quot;execvp error &quot; );     exit( 1 );   }</code></pre><p>   }</p></li></ul><h2 id="2-6-创建子进程并调用execle"><a href="#2-6-创建子进程并调用execle" class="headerlink" title="2.6 创建子进程并调用execle"></a>2.6 创建子进程并调用execle</h2><ul><li>l 　希望接收以逗号分隔的参数列表，列表以NULL指针作为结束标志</li><li><p>e　函数传递指定参数envp，允许改变子进程的环境，无后缀e时，子进程使用当前程序的环境</p><p>  if( fork() == 0 )<br>  {</p><pre><code>printf(&quot;5------------execle------------\n&quot;);if( execle(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-a&quot;, NULL, NULL) == -1 ){  perror(&quot;execle error &quot;);  exit(1);}</code></pre><p>  }</p></li></ul><h2 id="2-7-创建子进程并调用execve"><a href="#2-7-创建子进程并调用execve" class="headerlink" title="2.7 创建子进程并调用execve"></a>2.7 创建子进程并调用execve</h2><ul><li>v 　希望接收到一个以NULL结尾的字符串数组的指针</li><li><p>e 　函数传递指定参数envp，允许改变子进程的环境，无后缀e时，子进程使用当前程序的环境</p><pre><code>if( fork() == 0 ){  printf(&quot;6------------execve-----------\n&quot;);  if( execve( &quot;/bin/ls&quot;, arg, NULL ) == 0)  {   perror(&quot;execve error &quot;);    exit(1);  }}</code></pre></li></ul><h2 id="2-8-类exec函数"><a href="#2-8-类exec函数" class="headerlink" title="2.8 类exec函数"></a>2.8 类exec函数</h2><p>system：用来执行指定的命令或程序<br>    &gt;头文件:#include &lt;stdlib.h&gt;<br>     原型：int system(const char *command);<br>    参数： command 要执行的指令 或者程序<br>    返回值  失败  返回 -1<br>           成功  除此以外进程的 退出码！</p><p>实例：<br>    &gt;cmd[256];<br>    sprintf(cmd,”%s %s %s”,”./hello”,”1”,”2”)<br>    system(cmd);<br>总结进程：<br>    进程 就是向操作系统申请资源的最小单位！<br>    通过进程可实现并发！因为 进程就实现并发的一种机制！<br>    进程的地址空间相互独立 创建一个进程时其会拷贝父进程的所有数据和指令！<br>    进程间的数据独立！<br>文终。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、进程函数&quot;&gt;&lt;a href=&quot;#一、进程函数&quot; class=&quot;headerlink&quot; title=&quot;一、进程函数&quot;&gt;&lt;/a&gt;一、进程函数&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;background-color:rgb(125,255,0)&quot;&gt;　　进程——进程是独立功能的程序关于某个数据集合上的一次运行活动！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习之路" scheme="http://bclnc.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="进程与线程" scheme="http://bclnc.github.io/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>学习之路 —— 进程与线程　　（一）</title>
    <link href="http://bclnc.github.io/2018/09/20/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%20%E2%80%94%E2%80%94%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://bclnc.github.io/2018/09/20/学习之路 —— 进程与线程/</id>
    <published>2018-09-20T05:58:20.000Z</published>
    <updated>2018-12-06T03:37:49.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习之路-——-进程与线程"><a href="#学习之路-——-进程与线程" class="headerlink" title="学习之路 —— 进程与线程"></a>学习之路 —— 进程与线程</h1><h2 id="一、进程和线程关系及区别"><a href="#一、进程和线程关系及区别" class="headerlink" title="一、进程和线程关系及区别"></a>一、进程和线程关系及区别</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>　　进程是<strong>独立功能</strong>的程序关于某个<strong>数据集合</strong>上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。<br>　　线程是进程中的一个实体，是cpu调度和分配的基本单位，但线程基本不拥有系统资源。</p><h3 id="2、关系"><a href="#2、关系" class="headerlink" title="2、关系"></a>2、关系</h3><p>　　<br>　　进程是一个动态的概念，线程是进程中的一部分，<strong>一个程序至少有一个进程，一个进程至少有一个线程</strong>。两者均能实现并发。　　</p><p>###3、分别</p><p>　　1）地址空间：线程间共享同一进程的地址空间，进程有自己独立的地址空间。<br>　　2）资源拥有：进程是资源分配和拥有的单位，同进程的线程共享进程资源。　　　　</p><h3 id="4、优劣"><a href="#4、优劣" class="headerlink" title="4、优劣"></a>4、优劣</h3><p>　　1）线程是处理器调度的基本单位，其划分的尺度小于进程，使得多线程程序的并发性高。</p><p>　　2）进程在执行过程中拥有独立的内存单元，而多个线程之间共享内存，运行效率高，但由于共享内存，导致线程与线程间互有影响，其中一个线程死亡会导致整个进程死掉，所以多进程程序比多线程程序健壮，但进程切换耗费资源大，效益低。</p><p>　　3）线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>　　4）从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><p>　　5）线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习之路-——-进程与线程&quot;&gt;&lt;a href=&quot;#学习之路-——-进程与线程&quot; class=&quot;headerlink&quot; title=&quot;学习之路 —— 进程与线程&quot;&gt;&lt;/a&gt;学习之路 —— 进程与线程&lt;/h1&gt;&lt;h2 id=&quot;一、进程和线程关系及区别&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="学习之路" scheme="http://bclnc.github.io/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="进程与线程" scheme="http://bclnc.github.io/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>简易hexo的搭建　　（一）</title>
    <link href="http://bclnc.github.io/2018/09/08/hexo--%E6%90%AD%E5%BB%BA/"/>
    <id>http://bclnc.github.io/2018/09/08/hexo--搭建/</id>
    <published>2018-09-08T05:58:20.000Z</published>
    <updated>2019-01-04T16:34:25.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建须知"><a href="#搭建须知" class="headerlink" title="搭建须知"></a>搭建须知</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始前，你必须已经：</p><pre><code>1.有一个github账号2.安装好git for windows3.安装有node.js、npm，并有一定的了解</code></pre><p>详情请见<a href="https://eidolon.xyz/2019/01/04/git-hexo%E6%90%AD%E5%BB%BA%E5%89%8D%E4%BC%A0/" target="_blank" rel="noopener">git-hexo搭建前传</a></p><h1 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>　　新建一个名为 (用户名.github.io)的仓库，例如你的用户名为test<br>则创建一个名为test.github.io的仓库，将来你的网站访问地址为</p><pre><code>http：//用户名.github.io</code></pre><p>　　是不是很方便，但每个github账户只能有一个这样可以直接访问域名的仓库。创建成功后，以后你网站的所有代码都放在这个仓库啦。</p><p>新建仓库——点击右侧头像——点击your repositories——点击new——在repository name输入：用户名.github.io——create repository；</p><h2 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h2><p>　　为什么要配置这个呢，因为提交代码肯定是要拥有你的github权限才行，但直接使用用户名和密码太不安全了，所以使用SSH key来解决本地和服务器连接的问题。在git bush中输入</p><pre><code>$ cd ~/.ssh #检查本机已存在的ssh</code></pre><p>　　如果提示No such file or directory 说明是第一次使用git。</p><pre><code>$ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></pre><p>　　然后连续三次回车，最终生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，打开并复制其中的内容，打开github主页，进入个人设置-&gt;SSH and GPG keys -&gt;New SSH key。将内容粘贴到key中，title随便填，保存。</p><h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><pre><code>$ ssh -T git@github.com</code></pre><p>　　如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p><pre><code>Hi XXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><p>　　配置成功，但还得再配置两条</p><pre><code>$ git config --global user.name &quot;xxx&quot;// 你的github用户名，非昵称$ git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱</code></pre><h1 id="使用——hexo"><a href="#使用——hexo" class="headerlink" title="使用——hexo"></a>使用——hexo</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>$ npm install -g hexo</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>　　在电脑的某个地方新建一个hexo文件夹，例如我在c：\bin\hexo,记住安装位置，常用。</p><pre><code>$ cd /c/bin/hexo/$ hexo init</code></pre><p>　　hexo会自动下载一些文件在这个目录下．接下来：</p><pre><code>$ hexo g # 生成$ hexo s # 启动服务</code></pre><p>　　执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。</p><p>　　hexo s是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 我们将见到我们的第一篇文章，Hello World。</p><p>　　到现在，ｈｅｘｏ博客的搭建已经完成，摩天大楼的基石已经建立，接下来，就是美化，填充，与修缮了，随着本人的学习，hexo博客教程也将接着完善——敬请期待。　　　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;搭建须知&quot;&gt;&lt;a href=&quot;#搭建须知&quot; class=&quot;headerlink&quot; title=&quot;搭建须知&quot;&gt;&lt;/a&gt;搭建须知&lt;/h1&gt;&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="hexo" scheme="http://bclnc.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://bclnc.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
