<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学习之路 —— 进程与线程 （一）]]></title>
    <url>%2F2018%2F09%2F20%2F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%20%E2%80%94%E2%80%94%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[学习之路 —— 进程与线程一、进程和线程关系及区别1、定义 进程是独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。 线程是进程中的一个实体，是cpu调度和分配的基本单位，但线程基本不拥有系统资源。 2、关系 进程是一个动态的概念，线程是进程中的一部分，一个程序至少有一个进程，一个进程至少有一个线程。两者均能实现并发。 ###3、分别 1）地址空间：线程间共享同一进程的地址空间，进程有自己独立的地址空间。 2）资源拥有：进程是资源分配和拥有的单位，同进程的线程共享进程资源。 4、优劣 1）线程是处理器调度的基本单位，其划分的尺度小于进程，使得多线程程序的并发性高。 2）进程在执行过程中拥有独立的内存单元，而多个线程之间共享内存，运行效率高，但由于共享内存，导致线程与线程间互有影响，其中一个线程死亡会导致整个进程死掉，所以多进程程序比多线程程序健壮，但进程切换耗费资源大，效益低。 3）线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 4）从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 5）线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。]]></content>
      <categories>
        <category>学习之路</category>
      </categories>
      <tags>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习之路 —— 进程与线程 （二）]]></title>
    <url>%2F2018%2F09%2F20%2F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、进程 进程——进程是独立功能的程序关于某个数据集合上的一次运行活动！ 1.1 创建进程函数头文件： #include &lt;unistd.h&gt; 原型： pid_t fork(void); 功能：创建一个进程 返回值：子进程 返回0 父进程 返回子进程的ID fork简介：fork函数创建了一个新的进程，新的进程即子进程将复制父进程所有的数据与指令，子进程拥有独立的内存空间以及系统资源。 问题一：fork 成功后子进程从哪里开始执行？ 从调用完fork后面的语句处开始执行！ 问题二：父子进程的执行顺序是怎样的？ 由时间片轮转调度决定，没有固定的执行顺序。 问题三：什么是时间片？ 时间片：为实现并发，每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。若时间片结束进程还在运行，则cpu将被剥夺并分配给另一个进程，若进程在时间片结束前阻塞或结束，则cpu当即切换。系统内进程按时间顺序排成一个队列，每次调度，系统都将cpu分配给队内首进程，此进程用完它的时间片后被移动到队列的末尾，接着下一个执行。 时间片过短：导致过多的进程切换，降低效率。 时间片过长：引起对短的交互请求响应变差。 1.2 获取标识码函数头文件： #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; 原型： pid_t getpid(void); //获取本身ID pid_t getppid(void);//获取父进程ID 功能：获取进程号 返回值：返回所获取的PID 1.3 进程退出函数exit: 头文件：#include&lt;stdlib.h&gt; 原型：void exit(int status)； 功能：用来退出进程，进行清除操作 参数： 退出码，stasus用来存返回值。 _exit: 头文件：#include&lt;unistd.h&gt; 原型：void _exit(int status); 功能：用来退出进程，立即退出 参数： 退出码，stasus用来存返回值。 _Exit: 头文件：#include&lt;stdlib.h&gt; 原型：void _Exit(int status); 功能：用来退出进程，立即退出 参数： 退出码，stasus用来存返回值。 进程死亡：自杀与被杀。自杀：自然死亡与调用退出函数。思考：问题一：return和exit有什么区别？ a.exit是一个函数，有参数。exit执行完后把控制权交给系统。 b.return是函数执行完后的返回。renturn执行完后把控制权交给调用函数。 问题二：exit与_exit有什么异同？ 相同点：都是用来终止进程的，执行这两个函数时，系统无条件终止所有操作，清除数据，终止进程运行。不同点：_exit执行后立即返回给内核，exit先执行一些清除操作再将控制权交给内核。清除操作：刷新流（stdin，stdout …）,将缓冲区的数据处理完成。 c.通过实例来区别实例1：exit.c 1 #include “stdio.h”2 #include “stdlib.h”34 int main()5 {6 printf(“using exit—-\n”);7 printf(“This is the content in buffer”);8 exit(0);9 } 执行结果： using exit—-This is the content in buffer 实例2：_exit.c 1 #include”stdio.h”2 #include”unistd.h”34 int main(void)5 {6 printf(“using _exit–\n”);7 printf(“This is the content in buffer”);8 _exit(0);9 } 执行结果： using exit—- printf函数就是使用缓冲I/O的方式，该函数在遇到“\n”换行符时自动的从缓冲区中将记录读出。所以exit()将缓冲区的数据写完后才退出，而_exit()函数直接退出。 1.4等待子进程结束函数wait: 头文件：#include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; 原型：pid_t wait(int *status); 功能：等待任意一个子进程状态改变 参数： 退出码，stasus用来存子进程返回值。 返回值：成功返回 等待到的子进程进程号 失败返回-1 同时errno被设置 waitpid : 头文件：#include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; 原型：pid_t waitpid(pid_t pid, int *status, int options); 功能：等待任意一个子进程状态改变 参数： pid :指定要等待的进程号 stasus :用来存子进程返回值。 options :等待模式：0 表示默认选项 阻塞等待 WNOHANG 非阻塞等待 假设此时没有子进程退出就立刻返回 不用等待！ 返回值：成功返回 等待到的子进程进程号 失败返回-1 同时errno被设置 退出码解析：status用来保存子进程的退出状态的信息，用以下宏来解析。 WIFEXITED（status） ：如果为真，子进程正常退出。 WEXITSTATUS (status) ：返回子进程的退出码正常退出 main函数的返回值或者exit _Exit _exit 的参数WIFSIGNALED （status） ：如果为真则表示这个子进程是被一个信号干掉的！WCONTINUED （status） ：如果为真表示 这个子进程是被信号唤醒的！ 二、exec函数族 让另外一个程序文件的数据和指令集合 替换 之前拷贝的数据指令！注意这里的替换只能替换 用户数据和指令 系统数据无法替换！ 如图所示： 1.1综述exec函数族&gt;头文件：#include &lt;unistd.h&gt; 原型：#include &lt;unistd.h&gt; extern char **environ; int execl(const char *path,const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path,const char *arg,..., char * const envp[]); int execv(const char *path,char *const argv[]); int execvp(const char *file, char *const argv[]); int execve(const char *file,char *const argv[],char *const envp[]); 功能： exec函数族装入并运行程序path/file，并将参数arg0(arg1, arg2, argv[], envp[])传递给子程序 参数： path :要运行的程序 arg :存放参数。 返回值：出错返回-1， l：list：希望接收到以逗号分隔的参数列表，列表以NULL指针作为结束标志。 把要执行的那个程序文件的参数，以list的形式输出。v：vector：希望接收到一个以NULL结尾的字符串数组的指针（char* argv[]） 把要执行的程序文件的参数 以向量即数组的方式出现p:path：环境变量：整个系统中任何一个进程都可以访问的变量。 一个以NULL结尾的字符串数组指针，函数可以DOS的PATH变量查找子程序文件e:envp：函数传递指定参数envp，允许改变子进程的环境，无后缀e时，子进程使用当前程序的环境。是不是看的头皮发麻？实践出真知。实例如下： 2.1 头文件及字符串数组指针的声明#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; int main(int argc, char *argv[]) { //以NULL结尾的字符串数组的指针，适合包含v的exec函数参数 char *arg[] = {&quot;ls&quot;, &quot;-a&quot;, NULL}; ｝ 2.2 创建子进程并调用函数execl execl 中希望接收以逗号分隔的参数列 表，并以NULL指针为结束标志 if( fork() == 0 ) { // in clild printf( &quot;1------------execl------------\n&quot; ); if( execl( &quot;/bin/ls&quot;, &quot;ls&quot;,&quot;-a&quot;, NULL ) == -1 ) { perror( &quot;execl error &quot; ); exit(1); } } 2.3 创建子进程并调用函数execv execv中希望接收一个以NULL结尾的字符串数组的指针if( fork() == 0 ) { printf(&quot;2------------execv------------\n&quot;); if( execv( &quot;/bin/ls&quot;,arg) &lt; 0) { perror(&quot;execv error &quot;); exit(1); } } 2.4 创建子进程并调用 execlp l 希望接收以逗号分隔的参数列表，列表以NULL指针作为结束标志 p 是一个以NULL结尾的字符串数组指针，函数可以DOS的PATH变量查找子程序文件 if( fork() == 0 ) { printf(&quot;3------------execlp------------\n&quot;); if( execlp( &quot;ls&quot;, &quot;ls&quot;, &quot;-a&quot;, NULL ) &lt; 0 ) { perror( &quot;execlp error &quot; ); exit(1); } } 2.５ 创建子里程并调用execvp v 望接收到一个以NULL结尾的字符串数 组的指针 p 是一个以NULL结尾的字符串数组指针，函数可以DOS的PATH变量查找子程序文件 if( fork() == 0 ) { printf(&quot;4------------execvp------------\n&quot;); if( execvp( &quot;ls&quot;, arg ) &lt; 0 ) { perror( &quot;execvp error &quot; ); exit( 1 ); } } 2.6 创建子进程并调用execle l 希望接收以逗号分隔的参数列表，列表以NULL指针作为结束标志 e 函数传递指定参数envp，允许改变子进程的环境，无后缀e时，子进程使用当前程序的环境 if( fork() == 0 ) { printf(&quot;5------------execle------------\n&quot;); if( execle(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-a&quot;, NULL, NULL) == -1 ) { perror(&quot;execle error &quot;); exit(1); } } 2.7 创建子进程并调用execve v 希望接收到一个以NULL结尾的字符串数组的指针 e 函数传递指定参数envp，允许改变子进程的环境，无后缀e时，子进程使用当前程序的环境 if( fork() == 0 ) { printf(&quot;6------------execve-----------\n&quot;); if( execve( &quot;/bin/ls&quot;, arg, NULL ) == 0) { perror(&quot;execve error &quot;); exit(1); } } 2.8 类exec函数system：用来执行指定的命令或程序 &gt;头文件:#include &lt;stdlib.h&gt; 原型：int system(const char *command); 参数： command 要执行的指令 或者程序 返回值 失败 返回 -1 成功 除此以外进程的 退出码！ 实例： &gt;cmd[256]; sprintf(cmd,”%s %s %s”,”./hello”,”1”,”2”) system(cmd); 文终。]]></content>
      <categories>
        <category>学习之路</category>
      </categories>
      <tags>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易hexo的搭建 （一）]]></title>
    <url>%2F2018%2F09%2F08%2FGCC%E4%B8%8B%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%83%B0%E6%80%A7%E8%BF%90%E7%AE%97%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[搭建须知准备工作在开始前，你必须已经： 1.有一个github账号 2.安装好git for windows 3.安装有node.js、npm，并有一定的了解 搭建github博客创建仓库 新建一个名为 (用户名.github.io)的仓库，例如你的用户名为test则创建一个名为test.github.io的仓库，将来你的网站访问地址为 http：//用户名.github.io 是不是很方便，但每个github账户只能有一个这样可以直接访问域名的仓库。创建成功后，以后你网站的所有代码都放在这个仓库啦。 配置SSH key 为什么要配置这个呢，因为提交代码肯定是要拥有你的github权限才行，但直接使用用户名和密码太不安全了，所以使用SSH key来解决本地和服务器连接的问题。在git bush中输入 $ cd ~/.ssh #检查本机已存在的ssh 如果提示No such file or directory 说明是第一次使用git。 $ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后连续三次回车，最终生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，打开并复制其中的内容，打开github主页，进入个人设置-&gt;SSH and GPG keys -&gt;New SSH key。将内容粘贴到key中，title随便填，保存。 测试是否成功$ ssh -T git@github.com 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi XXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 配置成功，但还得再配置两条 $ git config --global user.name &quot;xxx&quot;// 你的github用户名，非昵称 $ git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 使用——hexo安装$ npm install -g hexo 初始化 在电脑的某个地方新建一个hexo文件夹，例如我在c：\bin\hexo,记住安装位置，常用。 $ cd /c/bin/hexo/ $ hexo init hexo会自动下载一些文件在这个目录下．接下来： $ hexo g # 生成 $ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。 hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 我们将见到我们的第一篇文章，Hello World。 到现在，ｈｅｘｏ博客的搭建已经完成，摩天大楼的基石已经建立，接下来，就是美化，填充，与修缮了，随着本人的学习，hexo博客教程也将接着完善——敬请期待。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
